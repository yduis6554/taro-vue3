{"version":3,"sources":["index.js","Errors.js","HttpClient.js","DefaultHttpClient.js","WeChatHttpClient.js","ILogger.js","HubConnection.js","HandshakeProtocol.js","TextMessageFormat.js","Utils.js","Loggers.js","IHubProtocol.js","Subject.js","HubConnectionBuilder.js","DefaultReconnectPolicy.js","HttpConnection.js","ITransport.js","WeChatWebSocketTransport.js","JsonHubProtocol.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;AGRA,AFMA,ACHA,AFMA;AGRA,AFMA,ACHA,AFMA;AGRA,AFMA,ACHA,AFMA;AGRA,AFMA,ACHA,AENA,AJYA;AGRA,AFMA,ACHA,AENA,AJYA;AGRA,AFMA,ACHA,AENA,AJYA;AGRA,AFMA,ACHA,AGTA,ADGA,AJYA;AGRA,AFMA,ACHA,AGTA,ADGA,AJYA;AGRA,AFMA,ACHA,AGTA,ADGA,AJYA;AGRA,AFMA,ACHA,AIZA,ADGA,ADGA,AJYA;AGRA,AFMA,ACHA,AIZA,ADGA,ADGA,AJYA;AGRA,AFMA,ACHA,AIZA,ADGA,ADGA,AJYA;AGRA,AFMA,AMlBA,ALeA,AIZA,ADGA,ADGA,AJYA;AGRA,AFMA,AMlBA,ALeA,AIZA,ADGA,ADGA,AJYA;AGRA,AFMA,AMlBA,ALeA,AIZA,ADGA,ADGA,AJYA;AGRA,AFMA,AMlBA,ALeA,AIZA,ADGA,AGTA,AJYA,AJYA;AGRA,AFMA,AMlBA,ALeA,AIZA,ADGA,AGTA,AJYA,AJYA;AGRA,AFMA,AMlBA,ALeA,AIZA,ADGA,AGTA,AJYA,AJYA;AGRA,AFMA,AMlBA,ALeA,AIZA,ADGA,AGTA,ACHA,ALeA,AJYA;AGRA,AFMA,AMlBA,ALeA,AIZA,ADGA,AGTA,ACHA,ALeA,AJYA;AGRA,AFMA,AMlBA,ALeA,AIZA,ADGA,AGTA,ACHA,ALeA,AJYA;AGRA,AFMA,AMlBA,ALeA,AIZA,ADGA,AKfA,AFMA,ACHA,ALeA,AJYA;AGRA,AFMA,AMlBA,ALeA,AIZA,ADGA,AKfA,AFMA,ACHA,ALeA,AJYA;AGRA,AFMA,AMlBA,ALeA,AIZA,ADGA,AKfA,AFMA,ACHA,ALeA,AJYA;AGRA,AFMA,AMlBA,ALeA,AIZA,AKfA,ANkBA,AKfA,AFMA,ACHA,ALeA,AJYA;AGRA,AFMA,AMlBA,ALeA,AIZA,AKfA,ANkBA,AKfA,AFMA,ACHA,ALeA,AJYA;AGRA,AFMA,AMlBA,ALeA,AIZA,AKfA,ANkBA,AKfA,AFMA,ACHA,ALeA;ADIA,AFMA,AMlBA,ALeA,AIZA,AKfA,ANkBA,AKfA,AENA,AJYA,ACHA,ALeA;ADIA,AFMA,AMlBA,ALeA,AIZA,AKfA,ANkBA,AKfA,AENA,AJYA,ACHA,ALeA;ADIA,AFMA,AMlBA,ALeA,AIZA,AKfA,ANkBA,AKfA,AENA,AJYA,ACHA,ALeA;ADIA,AFMA,AMlBA,ALeA,AIZA,AOrBA,AFMA,ANkBA,AKfA,AENA,AJYA,ACHA,ALeA;ADIA,AFMA,AMlBA,ALeA,AIZA,AOrBA,AFMA,ANkBA,AKfA,AENA,AJYA,ACHA,ALeA;ADIA,AFMA,AMlBA,ALeA,AIZA,AOrBA,AFMA,ANkBA,AKfA,AENA,AJYA,ACHA,ALeA;ADIA,AWjCA,AbuCA,AMlBA,ALeA,AIZA,AOrBA,AFMA,ADGA,AENA,AJYA,ACHA,ALeA;ADIA,AWjCA,AbuCA,AMlBA,ALeA,AIZA,AOrBA,AFMA,ADGA,AENA,AJYA,ACHA,ALeA;ADIA,AWjCA,AbuCA,AMlBA,ALeA,AIZA,AOrBA,AFMA,ADGA,AENA,AJYA,ACHA,ALeA;ADIA,AWjCA,AbuCA,AMlBA,ALeA,AavCA,AT2BA,AOrBA,AFMA,ADGA,AENA,AJYA,ACHA,ALeA;ADIA,AWjCA,AbuCA,AMlBA,ALeA,AavCA,AT2BA,AOrBA,AFMA,ADGA,AENA,AJYA,ACHA,ALeA;ADIA,AWjCA,AbuCA,AMlBA,ALeA,AavCA,AT2BA,AOrBA,AFMA,ADGA,AENA,AJYA,ACHA,ALeA;ADIA,AWjCA,AbuCA,AMlBA,ALeA,AavCA,AT2BA,AOrBA,AFMA,AKfA,AJYA,AJYA,ACHA,ALeA;ADIA,AWjCA,AbuCA,AMlBA,ALeA,AavCA,AT2BA,AOrBA,AFMA,AKfA,AJYA,AJYA,ACHA,ALeA;ADIA,AWjCA,AbuCA,AMlBA,ALeA,AavCA,AT2BA,AOrBA,AFMA,AKfA,AJYA,AHSA,ALeA;ADIA,AWjCA,AbuCA,AMlBA,ALeA,AavCA,AT2BA,AOrBA,AFMA,AKfA,AJYA,AHSA,ALeA,AavCA;Ad2CA,AWjCA,AbuCA,AMlBA,ALeA,AavCA,AT2BA,AOrBA,AFMA,AKfA,AJYA,AHSA,ALeA,AavCA;Ad2CA,AWjCA,AbuCA,AMlBA,ALeA,AavCA,AT2BA,AOrBA,AFMA,AKfA,AJYA,AHSA,ALeA,AavCA;Ad2CA,AWjCA,AbuCA,AMlBA,ALeA,AavCA,AT2BA,AOrBA,AFMA,AKfA,AENA,ANkBA,AHSA,ALeA,AavCA;Ad2CA,AWjCA,AbuCA,AMlBA,ALeA,AavCA,AT2BA,AOrBA,AFMA,AKfA,AENA,ANkBA,AHSA,ALeA,AavCA;Ad2CA,AWjCA,AbuCA,AMlBA,ALeA,AavCA,AT2BA,AOrBA,AGTA,AENA,ANkBA,AHSA,ALeA,AavCA;Ad2CA,AWjCA,AbuCA,AMlBA,ALeA,AavCA,AT2BA,AOrBA,AGTA,AENA,ANkBA,AHSA,ALeA,AavCA;Ad2CA,AWjCA,AbuCA,AMlBA,ALeA,AavCA,AT2BA,AOrBA,AGTA,AENA,ANkBA,AHSA,ALeA,AavCA;Ad2CA,AWjCA,AbuCA,AMlBA,ALeA,AavCA,AT2BA,AOrBA,AGTA,AENA,ANkBA,AHSA,ALeA,AavCA;Ad2CA,AWjCA,AbuCA,AMlBA,AQxBA,AT2BA,AOrBA,AGTA,AENA,ANkBA,AHSA,ALeA,AavCA;Ad2CA,AWjCA,AbuCA,AMlBA,AQxBA,AT2BA,AOrBA,AGTA,AENA,ANkBA,AHSA,ALeA,AavCA;Ad2CA,AWjCA,AbuCA,AMlBA,AQxBA,AT2BA,AOrBA,AGTA,AENA,ANkBA,AHSA,ALeA,AavCA;Ad2CA,AWjCA,AbuCA,AMlBA,AQxBA,AT2BA,AOrBA,AGTA,AENA,ANkBA,AHSA,ALeA,AavCA;Ad2CA,AWjCA,AbuCA,AMlBA,AQxBA,AT2BA,AOrBA,AGTA,AENA,ANkBA,AHSA,ALeA,AavCA;Ad2CA,AWjCA,AbuCA,AMlBA,AQxBA,AT2BA,AOrBA,AGTA,AENA,ANkBA,AHSA,ALeA,AavCA;AHUA,AbuCA,AMlBA,AQxBA,AT2BA,AOrBA,AGTA,AENA,ANkBA,AHSA,ALeA,AavCA;AhBiDA,AMlBA,AQxBA,AT2BA,AOrBA,AGTA,AENA,ANkBA,AHSA,ALeA,AavCA;AhBiDA,AMlBA,AQxBA,AT2BA,AOrBA,AGTA,AENA,ANkBA,AHSA,ALeA,AavCA;AhBiDA,AMlBA,AQxBA,AT2BA,AOrBA,AGTA,AENA,ANkBA,AHSA,ALeA,AavCA;AhBiDA,AMlBA,AQxBA,AT2BA,AOrBA,AGTA,AENA,ANkBA,AHSA,ALeA,AavCA;AhBiDA,AMlBA,AQxBA,AT2BA,AOrBA,AGTA,AENA,ANkBA,AHSA,ALeA,AavCA;AhBiDA,AMlBA,AQxBA,AT2BA,AOrBA,AGTA,AENA,ANkBA,AHSA,ALeA,AavCA;AhBiDA,AMlBA,AQxBA,AT2BA,AOrBA,AGTA,AENA,ANkBA,AHSA,ALeA,AavCA;AhBiDA,AMlBA,AQxBA,AT2BA,AOrBA,AKfA,ANkBA,AHSA,ALeA,AavCA;AhBiDA,AMlBA,AQxBA,AT2BA,AOrBA,AKfA,ANkBA,AHSA,ALeA,AavCA;AhBiDA,AMlBA,AQxBA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AhBiDA,AMlBA,AQxBA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AhBiDA,AMlBA,AQxBA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AhBiDA,Ac1CA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AhBiDA,Ac1CA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AhBiDA,Ac1CA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AhBiDA,Ac1CA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AhBiDA,Ac1CA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AhBiDA,Ac1CA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,ALeA,AavCA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,AQxBA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,AQxBA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,AQxBA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,AQxBA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,AQxBA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,AQxBA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,AQxBA;AFOA,AT2BA,AOrBA,AKfA,AT2BA,AQxBA;AFOA,AT2BA,AOrBA,AJYA,AQxBA;AFOA,AT2BA,AOrBA,AJYA,AQxBA;AFOA,AT2BA,AOrBA,AJYA,AQxBA;AFOA,AT2BA,AOrBA,AJYA,AQxBA;AFOA,AT2BA,AOrBA,AJYA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA,AQxBA;AFOA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA,AGTA;AMjBA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Version token that will be replaced by the prepack command\r\n/** The version of the SignalR client. */\r\nexports.VERSION = \"0.0.0-DEV_BUILD\";\r\nvar Errors_1 = require(\"./Errors\");\r\nexports.AbortError = Errors_1.AbortError;\r\nexports.HttpError = Errors_1.HttpError;\r\nexports.TimeoutError = Errors_1.TimeoutError;\r\nvar HttpClient_1 = require(\"./HttpClient\");\r\nexports.HttpClient = HttpClient_1.HttpClient;\r\nexports.HttpResponse = HttpClient_1.HttpResponse;\r\nvar DefaultHttpClient_1 = require(\"./DefaultHttpClient\");\r\nexports.DefaultHttpClient = DefaultHttpClient_1.DefaultHttpClient;\r\nvar HubConnection_1 = require(\"./HubConnection\");\r\nexports.HubConnection = HubConnection_1.HubConnection;\r\nexports.HubConnectionState = HubConnection_1.HubConnectionState;\r\nvar HubConnectionBuilder_1 = require(\"./HubConnectionBuilder\");\r\nexports.HubConnectionBuilder = HubConnectionBuilder_1.HubConnectionBuilder;\r\nvar IHubProtocol_1 = require(\"./IHubProtocol\");\r\nexports.MessageType = IHubProtocol_1.MessageType;\r\nvar ILogger_1 = require(\"./ILogger\");\r\nexports.LogLevel = ILogger_1.LogLevel;\r\nvar ITransport_1 = require(\"./ITransport\");\r\nexports.HttpTransportType = ITransport_1.HttpTransportType;\r\nexports.TransferFormat = ITransport_1.TransferFormat;\r\nvar Loggers_1 = require(\"./Loggers\");\r\nexports.NullLogger = Loggers_1.NullLogger;\r\nvar JsonHubProtocol_1 = require(\"./JsonHubProtocol\");\r\nexports.JsonHubProtocol = JsonHubProtocol_1.JsonHubProtocol;\r\nvar Subject_1 = require(\"./Subject\");\r\nexports.Subject = Subject_1.Subject;\r\n//# sourceMappingURL=index.js.map","\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** Error thrown when an HTTP request fails. */\r\nvar HttpError = /** @class */ (function (_super) {\r\n    __extends(HttpError, _super);\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     * @param {number} statusCode The HTTP status code represented by this error.\r\n     */\r\n    function HttpError(errorMessage, statusCode) {\r\n        var _newTarget = this.constructor;\r\n        var _this = this;\r\n        var trueProto = _newTarget.prototype;\r\n        _this = _super.call(this, errorMessage) || this;\r\n        _this.statusCode = statusCode;\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        _this.__proto__ = trueProto;\r\n        return _this;\r\n    }\r\n    return HttpError;\r\n}(Error));\r\nexports.HttpError = HttpError;\r\n/** Error thrown when a timeout elapses. */\r\nvar TimeoutError = /** @class */ (function (_super) {\r\n    __extends(TimeoutError, _super);\r\n    /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    function TimeoutError(errorMessage) {\r\n        var _newTarget = this.constructor;\r\n        if (errorMessage === void 0) { errorMessage = \"A timeout occurred.\"; }\r\n        var _this = this;\r\n        var trueProto = _newTarget.prototype;\r\n        _this = _super.call(this, errorMessage) || this;\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        _this.__proto__ = trueProto;\r\n        return _this;\r\n    }\r\n    return TimeoutError;\r\n}(Error));\r\nexports.TimeoutError = TimeoutError;\r\n/** Error thrown when an action is aborted. */\r\nvar AbortError = /** @class */ (function (_super) {\r\n    __extends(AbortError, _super);\r\n    /** Constructs a new instance of {@link AbortError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    function AbortError(errorMessage) {\r\n        var _newTarget = this.constructor;\r\n        if (errorMessage === void 0) { errorMessage = \"An abort occurred.\"; }\r\n        var _this = this;\r\n        var trueProto = _newTarget.prototype;\r\n        _this = _super.call(this, errorMessage) || this;\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        _this.__proto__ = trueProto;\r\n        return _this;\r\n    }\r\n    return AbortError;\r\n}(Error));\r\nexports.AbortError = AbortError;\r\n//# sourceMappingURL=Errors.js.map","\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** Represents an HTTP response. */\r\nvar HttpResponse = /** @class */ (function () {\r\n    function HttpResponse(statusCode, statusText, content) {\r\n        this.statusCode = statusCode;\r\n        this.statusText = statusText;\r\n        this.content = content;\r\n    }\r\n    return HttpResponse;\r\n}());\r\nexports.HttpResponse = HttpResponse;\r\n/** Abstraction over an HTTP client.\r\n *\r\n * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.\r\n */\r\nvar HttpClient = /** @class */ (function () {\r\n    function HttpClient() {\r\n    }\r\n    HttpClient.prototype.get = function (url, options) {\r\n        return this.send(__assign(__assign({}, options), { method: \"GET\", url: url }));\r\n    };\r\n    HttpClient.prototype.post = function (url, options) {\r\n        return this.send(__assign(__assign({}, options), { method: \"POST\", url: url }));\r\n    };\r\n    HttpClient.prototype.delete = function (url, options) {\r\n        return this.send(__assign(__assign({}, options), { method: \"DELETE\", url: url }));\r\n    };\r\n    /** Gets all cookies that apply to the specified URL.\r\n     *\r\n     * @param url The URL that the cookies are valid for.\r\n     * @returns {string} A string containing all the key-value cookie pairs for the specified URL.\r\n     */\r\n    // @ts-ignore\r\n    HttpClient.prototype.getCookieString = function (url) {\r\n        return \"\";\r\n    };\r\n    return HttpClient;\r\n}());\r\nexports.HttpClient = HttpClient;\r\n//# sourceMappingURL=HttpClient.js.map","\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Errors_1 = require(\"./Errors\");\r\nvar HttpClient_1 = require(\"./HttpClient\");\r\nvar WeChatHttpClient_1 = require(\"./WeChatHttpClient\");\r\n/** Default implementation of {@link @microsoft/signalr.HttpClient}. */\r\nvar DefaultHttpClient = /** @class */ (function (_super) {\r\n    __extends(DefaultHttpClient, _super);\r\n    /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */\r\n    function DefaultHttpClient(logger) {\r\n        var _this = _super.call(this) || this;\r\n        _this.httpClient = new WeChatHttpClient_1.WeChatHttpClient(logger);\r\n        return _this;\r\n        // if (typeof fetch !== \"undefined\") {\r\n        //    this.httpClient = new FetchHttpClient(logger);\r\n        // } else if (typeof XMLHttpRequest !== \"undefined\") {\r\n        //    this.httpClient = new XhrHttpClient(logger);\r\n        // } else {\r\n        //    this.httpClient = new NodeHttpClient(logger);\r\n        // }\r\n    }\r\n    /** @inheritDoc */\r\n    DefaultHttpClient.prototype.send = function (request) {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new Errors_1.AbortError());\r\n        }\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n        return this.httpClient.send(request);\r\n    };\r\n    DefaultHttpClient.prototype.getCookieString = function (url) {\r\n        return this.httpClient.getCookieString(url);\r\n    };\r\n    return DefaultHttpClient;\r\n}(HttpClient_1.HttpClient));\r\nexports.DefaultHttpClient = DefaultHttpClient;\r\n//# sourceMappingURL=DefaultHttpClient.js.map","\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Errors_1 = require(\"./Errors\");\r\nvar HttpClient_1 = require(\"./HttpClient\");\r\nvar ILogger_1 = require(\"./ILogger\");\r\nvar WeChatHttpClient = /** @class */ (function (_super) {\r\n    __extends(WeChatHttpClient, _super);\r\n    function WeChatHttpClient(logger) {\r\n        var _a;\r\n        var _this = _super.call(this) || this;\r\n        _this.logger = logger;\r\n        _this.knownStateTextMap = (_a = {},\r\n            _a[100] = \"Continue\",\r\n            _a[101] = \"Switching Protocols\",\r\n            _a[102] = \"Processing\",\r\n            _a[200] = \"Ok\",\r\n            _a[201] = \"Created\",\r\n            _a[202] = \"Accepted\",\r\n            _a[203] = \"Non-Authoritative Information\",\r\n            _a[204] = \"No Content\",\r\n            _a[205] = \"Reset Content\",\r\n            _a[206] = \"Partial Content\",\r\n            _a[207] = \"Multi-Status\",\r\n            _a[300] = \"Multiple Choices\",\r\n            _a[301] = \"Moved Permanently\",\r\n            _a[302] = \"Move Temporarily\",\r\n            _a[303] = \"See Other\",\r\n            _a[304] = \"Not Modified\",\r\n            _a[305] = \"Use Proxy\",\r\n            _a[306] = \"Switch Proxy\",\r\n            _a[307] = \"Temporary Redirect\",\r\n            _a[400] = \"Bad Request\",\r\n            _a[401] = \"Unauthenticated\",\r\n            _a[402] = \"Payment Required\",\r\n            _a[403] = \"Forbidden\",\r\n            _a[404] = \"Not Found\",\r\n            _a[405] = \"Method Not Allowed\",\r\n            _a[406] = \"Not Acceptable\",\r\n            _a[408] = \"Request Timeout\",\r\n            _a[415] = \"Unsupported Media Type\",\r\n            _a[500] = \"Internal Server Error\",\r\n            _a[501] = \"Not Implemented\",\r\n            _a[502] = \"Bad Gateway\",\r\n            _a[503] = \"Service Unavailable\",\r\n            _a[600] = \"Unparseable Response Headers\",\r\n            _a);\r\n        return _this;\r\n    }\r\n    /** @inheritdoc */\r\n    WeChatHttpClient.prototype.send = function (request) {\r\n        var _this = this;\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new Errors_1.AbortError());\r\n        }\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n        return new Promise(function (resolve, reject) {\r\n            var xhr = wx.request({\r\n                data: request.content,\r\n                method: request.method,\r\n                url: request.url,\r\n                header: __assign(__assign({}, request.headers), { \"X-Requested-With\": \"XMLHttpRequest\", \"Content-Type\": \"text/plain;charset=UTF-8\" }),\r\n                fail: function (response) {\r\n                    _this.logger.log(ILogger_1.LogLevel.Warning, \"Error from HTTP request. \" + response.errMsg + \".\");\r\n                    reject(new Errors_1.HttpError(response.errMsg, 500)); // no status code\r\n                },\r\n                success: function (response) {\r\n                    if (request.abortSignal) {\r\n                        request.abortSignal.onabort = null;\r\n                    }\r\n                    if (response.statusCode >= 200 && response.statusCode < 300) {\r\n                        var content = void 0;\r\n                        if (typeof response.data === \"object\") {\r\n                            content = JSON.stringify(response.data);\r\n                        }\r\n                        else {\r\n                            content = response.data;\r\n                        }\r\n                        resolve(new HttpClient_1.HttpResponse(response.statusCode, _this.mapStatusCode(response.statusCode), content));\r\n                    }\r\n                    else {\r\n                        reject(new Errors_1.HttpError(response.errMsg, response.statusCode));\r\n                    }\r\n                }\r\n            });\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = function () {\r\n                    xhr.abort();\r\n                    reject(new Errors_1.AbortError());\r\n                };\r\n            }\r\n            // timeout is not supported in wx.request()\r\n            // if (request.timeout) {\r\n            //     xhr.timeout = request.timeout;\r\n            // }\r\n            // timeout is not supported in wx.request()\r\n            // xhr.ontimeout = () => {\r\n            //     this.logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n            //     reject(new TimeoutError());\r\n            // };\r\n        });\r\n    };\r\n    WeChatHttpClient.prototype.mapStatusCode = function (statusCode) {\r\n        var x = this.knownStateTextMap[statusCode];\r\n        if (x) {\r\n            return x;\r\n        }\r\n        return \"unknow state\";\r\n    };\r\n    return WeChatHttpClient;\r\n}(HttpClient_1.HttpClient));\r\nexports.WeChatHttpClient = WeChatHttpClient;\r\n//# sourceMappingURL=WeChatHttpClient.js.map","\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.\r\n/** Indicates the severity of a log message.\r\n *\r\n * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.\r\n */\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n    /** Log level for very low severity diagnostic messages. */\r\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\r\n    /** Log level for low severity diagnostic messages. */\r\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\r\n    /** Log level for informational diagnostic messages. */\r\n    LogLevel[LogLevel[\"Information\"] = 2] = \"Information\";\r\n    /** Log level for diagnostic messages that indicate a non-fatal problem. */\r\n    LogLevel[LogLevel[\"Warning\"] = 3] = \"Warning\";\r\n    /** Log level for diagnostic messages that indicate a failure in the current operation. */\r\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\r\n    /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */\r\n    LogLevel[LogLevel[\"Critical\"] = 5] = \"Critical\";\r\n    /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */\r\n    LogLevel[LogLevel[\"None\"] = 6] = \"None\";\r\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\r\n//# sourceMappingURL=ILogger.js.map","\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar HandshakeProtocol_1 = require(\"./HandshakeProtocol\");\r\nvar IHubProtocol_1 = require(\"./IHubProtocol\");\r\nvar ILogger_1 = require(\"./ILogger\");\r\nvar Subject_1 = require(\"./Subject\");\r\nvar Utils_1 = require(\"./Utils\");\r\nvar DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\r\nvar DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;\r\n/** Describes the current state of the {@link HubConnection} to the server. */\r\nvar HubConnectionState;\r\n(function (HubConnectionState) {\r\n    /** The hub connection is disconnected. */\r\n    HubConnectionState[\"Disconnected\"] = \"Disconnected\";\r\n    /** The hub connection is connecting. */\r\n    HubConnectionState[\"Connecting\"] = \"Connecting\";\r\n    /** The hub connection is connected. */\r\n    HubConnectionState[\"Connected\"] = \"Connected\";\r\n    /** The hub connection is disconnecting. */\r\n    HubConnectionState[\"Disconnecting\"] = \"Disconnecting\";\r\n    /** The hub connection is reconnecting. */\r\n    HubConnectionState[\"Reconnecting\"] = \"Reconnecting\";\r\n})(HubConnectionState = exports.HubConnectionState || (exports.HubConnectionState = {}));\r\n/** Represents a connection to a SignalR Hub. */\r\nvar HubConnection = /** @class */ (function () {\r\n    function HubConnection(connection, logger, protocol, reconnectPolicy) {\r\n        var _this = this;\r\n        Utils_1.Arg.isRequired(connection, \"connection\");\r\n        Utils_1.Arg.isRequired(logger, \"logger\");\r\n        Utils_1.Arg.isRequired(protocol, \"protocol\");\r\n        this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\r\n        this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\r\n        this.logger = logger;\r\n        this.protocol = protocol;\r\n        this.connection = connection;\r\n        this.reconnectPolicy = reconnectPolicy;\r\n        this.handshakeProtocol = new HandshakeProtocol_1.HandshakeProtocol();\r\n        this.connection.onreceive = function (data) { return _this.processIncomingData(data); };\r\n        this.connection.onclose = function (error) { return _this.connectionClosed(error); };\r\n        this.callbacks = {};\r\n        this.methods = {};\r\n        this.closedCallbacks = [];\r\n        this.reconnectingCallbacks = [];\r\n        this.reconnectedCallbacks = [];\r\n        this.invocationId = 0;\r\n        this.receivedHandshakeResponse = false;\r\n        this.connectionState = HubConnectionState.Disconnected;\r\n        this.connectionStarted = false;\r\n        this.cachedPingMessage = this.protocol.writeMessage({ type: IHubProtocol_1.MessageType.Ping });\r\n    }\r\n    /** @internal */\r\n    // Using a public static factory method means we can have a private constructor and an _internal_\r\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\r\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\r\n    // public parameter-less constructor.\r\n    HubConnection.create = function (connection, logger, protocol, reconnectPolicy) {\r\n        return new HubConnection(connection, logger, protocol, reconnectPolicy);\r\n    };\r\n    Object.defineProperty(HubConnection.prototype, \"state\", {\r\n        /** Indicates the state of the {@link HubConnection} to the server. */\r\n        get: function () {\r\n            return this.connectionState;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(HubConnection.prototype, \"connectionId\", {\r\n        /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n         *  in the disconnected state or if the negotiation step was skipped.\r\n         */\r\n        get: function () {\r\n            return this.connection ? (this.connection.connectionId || null) : null;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(HubConnection.prototype, \"baseUrl\", {\r\n        /** Indicates the url of the {@link HubConnection} to the server. */\r\n        get: function () {\r\n            return this.connection.baseUrl || \"\";\r\n        },\r\n        /**\r\n         * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n         * Reconnecting states.\r\n         * @param {string} url The url to connect to.\r\n         */\r\n        set: function (url) {\r\n            if (this.connectionState !== HubConnectionState.Disconnected && this.connectionState !== HubConnectionState.Reconnecting) {\r\n                throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\r\n            }\r\n            if (!url) {\r\n                throw new Error(\"The HubConnection url must be a valid url.\");\r\n            }\r\n            this.connection.baseUrl = url;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\r\n    HubConnection.prototype.start = function () {\r\n        this.startPromise = this.startWithStateTransitions();\r\n        return this.startPromise;\r\n    };\r\n    HubConnection.prototype.startWithStateTransitions = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var e_1;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (this.connectionState !== HubConnectionState.Disconnected) {\r\n                            return [2 /*return*/, Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"))];\r\n                        }\r\n                        this.connectionState = HubConnectionState.Connecting;\r\n                        this.logger.log(ILogger_1.LogLevel.Debug, \"Starting HubConnection.\");\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, this.startInternal()];\r\n                    case 2:\r\n                        _a.sent();\r\n                        this.connectionState = HubConnectionState.Connected;\r\n                        this.connectionStarted = true;\r\n                        this.logger.log(ILogger_1.LogLevel.Debug, \"HubConnection connected successfully.\");\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        e_1 = _a.sent();\r\n                        this.connectionState = HubConnectionState.Disconnected;\r\n                        this.logger.log(ILogger_1.LogLevel.Debug, \"HubConnection failed to start successfully because of error '\" + e_1 + \"'.\");\r\n                        return [2 /*return*/, Promise.reject(e_1)];\r\n                    case 4: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HubConnection.prototype.startInternal = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var handshakePromise, handshakeRequest, e_2;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        this.stopDuringStartError = undefined;\r\n                        this.receivedHandshakeResponse = false;\r\n                        handshakePromise = new Promise(function (resolve, reject) {\r\n                            _this.handshakeResolver = resolve;\r\n                            _this.handshakeRejecter = reject;\r\n                        });\r\n                        return [4 /*yield*/, this.connection.start(this.protocol.transferFormat)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        _a.trys.push([2, 5, , 7]);\r\n                        handshakeRequest = {\r\n                            protocol: this.protocol.name,\r\n                            version: this.protocol.version,\r\n                        };\r\n                        this.logger.log(ILogger_1.LogLevel.Debug, \"Sending handshake request.\");\r\n                        return [4 /*yield*/, this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest))];\r\n                    case 3:\r\n                        _a.sent();\r\n                        this.logger.log(ILogger_1.LogLevel.Information, \"Using HubProtocol '\" + this.protocol.name + \"'.\");\r\n                        // defensively cleanup timeout in case we receive a message from the server before we finish start\r\n                        this.cleanupTimeout();\r\n                        this.resetTimeoutPeriod();\r\n                        this.resetKeepAliveInterval();\r\n                        return [4 /*yield*/, handshakePromise];\r\n                    case 4:\r\n                        _a.sent();\r\n                        // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\r\n                        // being rejected on close, because this continuation can run after both the handshake completed successfully\r\n                        // and the connection was closed.\r\n                        if (this.stopDuringStartError) {\r\n                            // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\r\n                            // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\r\n                            // will cause the calling continuation to get scheduled to run later.\r\n                            throw this.stopDuringStartError;\r\n                        }\r\n                        return [3 /*break*/, 7];\r\n                    case 5:\r\n                        e_2 = _a.sent();\r\n                        this.logger.log(ILogger_1.LogLevel.Debug, \"Hub handshake failed with error '\" + e_2 + \"' during start(). Stopping HubConnection.\");\r\n                        this.cleanupTimeout();\r\n                        this.cleanupPingTimer();\r\n                        // HttpConnection.stop() should not complete until after the onclose callback is invoked.\r\n                        // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\r\n                        return [4 /*yield*/, this.connection.stop(e_2)];\r\n                    case 6:\r\n                        // HttpConnection.stop() should not complete until after the onclose callback is invoked.\r\n                        // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\r\n                        _a.sent();\r\n                        throw e_2;\r\n                    case 7: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\r\n    HubConnection.prototype.stop = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var startPromise, e_3;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        startPromise = this.startPromise;\r\n                        this.stopPromise = this.stopInternal();\r\n                        return [4 /*yield*/, this.stopPromise];\r\n                    case 1:\r\n                        _a.sent();\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        _a.trys.push([2, 4, , 5]);\r\n                        // Awaiting undefined continues immediately\r\n                        return [4 /*yield*/, startPromise];\r\n                    case 3:\r\n                        // Awaiting undefined continues immediately\r\n                        _a.sent();\r\n                        return [3 /*break*/, 5];\r\n                    case 4:\r\n                        e_3 = _a.sent();\r\n                        return [3 /*break*/, 5];\r\n                    case 5: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HubConnection.prototype.stopInternal = function (error) {\r\n        if (this.connectionState === HubConnectionState.Disconnected) {\r\n            this.logger.log(ILogger_1.LogLevel.Debug, \"Call to HubConnection.stop(\" + error + \") ignored because it is already in the disconnected state.\");\r\n            return Promise.resolve();\r\n        }\r\n        if (this.connectionState === HubConnectionState.Disconnecting) {\r\n            this.logger.log(ILogger_1.LogLevel.Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnecting state.\");\r\n            return this.stopPromise;\r\n        }\r\n        this.connectionState = HubConnectionState.Disconnecting;\r\n        this.logger.log(ILogger_1.LogLevel.Debug, \"Stopping HubConnection.\");\r\n        if (this.reconnectDelayHandle) {\r\n            // We're in a reconnect delay which means the underlying connection is currently already stopped.\r\n            // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\r\n            // fire the onclose callbacks.\r\n            this.logger.log(ILogger_1.LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\r\n            clearTimeout(this.reconnectDelayHandle);\r\n            this.reconnectDelayHandle = undefined;\r\n            this.completeClose();\r\n            return Promise.resolve();\r\n        }\r\n        this.cleanupTimeout();\r\n        this.cleanupPingTimer();\r\n        this.stopDuringStartError = error || new Error(\"The connection was stopped before the hub handshake could complete.\");\r\n        // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\r\n        // or the onclose callback is invoked. The onclose callback will transition the HubConnection\r\n        // to the disconnected state if need be before HttpConnection.stop() completes.\r\n        return this.connection.stop(error);\r\n    };\r\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\r\n    HubConnection.prototype.stream = function (methodName) {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var _a = this.replaceStreamingParams(args), streams = _a[0], streamIds = _a[1];\r\n        var invocationDescriptor = this.createStreamInvocation(methodName, args, streamIds);\r\n        var promiseQueue;\r\n        var subject = new Subject_1.Subject();\r\n        subject.cancelCallback = function () {\r\n            var cancelInvocation = _this.createCancelInvocation(invocationDescriptor.invocationId);\r\n            delete _this.callbacks[invocationDescriptor.invocationId];\r\n            return promiseQueue.then(function () {\r\n                return _this.sendWithProtocol(cancelInvocation);\r\n            });\r\n        };\r\n        this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\r\n            if (error) {\r\n                subject.error(error);\r\n                return;\r\n            }\r\n            else if (invocationEvent) {\r\n                // invocationEvent will not be null when an error is not passed to the callback\r\n                if (invocationEvent.type === IHubProtocol_1.MessageType.Completion) {\r\n                    if (invocationEvent.error) {\r\n                        subject.error(new Error(invocationEvent.error));\r\n                    }\r\n                    else {\r\n                        subject.complete();\r\n                    }\r\n                }\r\n                else {\r\n                    subject.next((invocationEvent.item));\r\n                }\r\n            }\r\n        };\r\n        promiseQueue = this.sendWithProtocol(invocationDescriptor)\r\n            .catch(function (e) {\r\n            subject.error(e);\r\n            delete _this.callbacks[invocationDescriptor.invocationId];\r\n        });\r\n        this.launchStreams(streams, promiseQueue);\r\n        return subject;\r\n    };\r\n    HubConnection.prototype.sendMessage = function (message) {\r\n        this.resetKeepAliveInterval();\r\n        return this.connection.send(message);\r\n    };\r\n    /**\r\n     * Sends a js object to the server.\r\n     * @param message The js object to serialize and send.\r\n     */\r\n    HubConnection.prototype.sendWithProtocol = function (message) {\r\n        return this.sendMessage(this.protocol.writeMessage(message));\r\n    };\r\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\r\n    HubConnection.prototype.send = function (methodName) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var _a = this.replaceStreamingParams(args), streams = _a[0], streamIds = _a[1];\r\n        var sendPromise = this.sendWithProtocol(this.createInvocation(methodName, args, true, streamIds));\r\n        this.launchStreams(streams, sendPromise);\r\n        return sendPromise;\r\n    };\r\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\r\n    HubConnection.prototype.invoke = function (methodName) {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var _a = this.replaceStreamingParams(args), streams = _a[0], streamIds = _a[1];\r\n        var invocationDescriptor = this.createInvocation(methodName, args, false, streamIds);\r\n        var p = new Promise(function (resolve, reject) {\r\n            // invocationId will always have a value for a non-blocking invocation\r\n            _this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                }\r\n                else if (invocationEvent) {\r\n                    // invocationEvent will not be null when an error is not passed to the callback\r\n                    if (invocationEvent.type === IHubProtocol_1.MessageType.Completion) {\r\n                        if (invocationEvent.error) {\r\n                            reject(new Error(invocationEvent.error));\r\n                        }\r\n                        else {\r\n                            resolve(invocationEvent.result);\r\n                        }\r\n                    }\r\n                    else {\r\n                        reject(new Error(\"Unexpected message type: \" + invocationEvent.type));\r\n                    }\r\n                }\r\n            };\r\n            var promiseQueue = _this.sendWithProtocol(invocationDescriptor)\r\n                .catch(function (e) {\r\n                reject(e);\r\n                // invocationId will always have a value for a non-blocking invocation\r\n                delete _this.callbacks[invocationDescriptor.invocationId];\r\n            });\r\n            _this.launchStreams(streams, promiseQueue);\r\n        });\r\n        return p;\r\n    };\r\n    /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n     *\r\n     * @param {string} methodName The name of the hub method to define.\r\n     * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n     */\r\n    HubConnection.prototype.on = function (methodName, newMethod) {\r\n        if (!methodName || !newMethod) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        if (!this.methods[methodName]) {\r\n            this.methods[methodName] = [];\r\n        }\r\n        // Preventing adding the same handler multiple times.\r\n        if (this.methods[methodName].indexOf(newMethod) !== -1) {\r\n            return;\r\n        }\r\n        this.methods[methodName].push(newMethod);\r\n    };\r\n    HubConnection.prototype.off = function (methodName, method) {\r\n        if (!methodName) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        var handlers = this.methods[methodName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        if (method) {\r\n            var removeIdx = handlers.indexOf(method);\r\n            if (removeIdx !== -1) {\r\n                handlers.splice(removeIdx, 1);\r\n                if (handlers.length === 0) {\r\n                    delete this.methods[methodName];\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            delete this.methods[methodName];\r\n        }\r\n    };\r\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\r\n    HubConnection.prototype.onclose = function (callback) {\r\n        if (callback) {\r\n            this.closedCallbacks.push(callback);\r\n        }\r\n    };\r\n    /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n     */\r\n    HubConnection.prototype.onreconnecting = function (callback) {\r\n        if (callback) {\r\n            this.reconnectingCallbacks.push(callback);\r\n        }\r\n    };\r\n    /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n     */\r\n    HubConnection.prototype.onreconnected = function (callback) {\r\n        if (callback) {\r\n            this.reconnectedCallbacks.push(callback);\r\n        }\r\n    };\r\n    HubConnection.prototype.processIncomingData = function (data) {\r\n        this.cleanupTimeout();\r\n        if (!this.receivedHandshakeResponse) {\r\n            data = this.processHandshakeResponse(data);\r\n            this.receivedHandshakeResponse = true;\r\n        }\r\n        // Data may have all been read when processing handshake response\r\n        if (data) {\r\n            // Parse the messages\r\n            var messages = this.protocol.parseMessages(data, this.logger);\r\n            for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {\r\n                var message = messages_1[_i];\r\n                switch (message.type) {\r\n                    case IHubProtocol_1.MessageType.Invocation:\r\n                        this.invokeClientMethod(message);\r\n                        break;\r\n                    case IHubProtocol_1.MessageType.StreamItem:\r\n                    case IHubProtocol_1.MessageType.Completion:\r\n                        var callback = this.callbacks[message.invocationId];\r\n                        if (callback) {\r\n                            if (message.type === IHubProtocol_1.MessageType.Completion) {\r\n                                delete this.callbacks[message.invocationId];\r\n                            }\r\n                            callback(message);\r\n                        }\r\n                        break;\r\n                    case IHubProtocol_1.MessageType.Ping:\r\n                        // Don't care about pings\r\n                        break;\r\n                    case IHubProtocol_1.MessageType.Close:\r\n                        this.logger.log(ILogger_1.LogLevel.Information, \"Close message received from server.\");\r\n                        // We don't want to wait on the stop itself.\r\n                        this.stopPromise = this.stopInternal(message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined);\r\n                        break;\r\n                    default:\r\n                        this.logger.log(ILogger_1.LogLevel.Warning, \"Invalid message type: \" + message.type + \".\");\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        this.resetTimeoutPeriod();\r\n    };\r\n    HubConnection.prototype.processHandshakeResponse = function (data) {\r\n        var _a;\r\n        var responseMessage;\r\n        var remainingData;\r\n        try {\r\n            _a = this.handshakeProtocol.parseHandshakeResponse(data), remainingData = _a[0], responseMessage = _a[1];\r\n        }\r\n        catch (e) {\r\n            var message = \"Error parsing handshake response: \" + e;\r\n            this.logger.log(ILogger_1.LogLevel.Error, message);\r\n            var error = new Error(message);\r\n            this.handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        if (responseMessage.error) {\r\n            var message = \"Server returned handshake error: \" + responseMessage.error;\r\n            this.logger.log(ILogger_1.LogLevel.Error, message);\r\n            var error = new Error(message);\r\n            this.handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        else {\r\n            this.logger.log(ILogger_1.LogLevel.Debug, \"Server handshake complete.\");\r\n        }\r\n        this.handshakeResolver();\r\n        return remainingData;\r\n    };\r\n    HubConnection.prototype.resetKeepAliveInterval = function () {\r\n        var _this = this;\r\n        this.cleanupPingTimer();\r\n        this.pingServerHandle = setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {\r\n            var _a;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        if (!(this.connectionState === HubConnectionState.Connected)) return [3 /*break*/, 4];\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        _b.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, this.sendMessage(this.cachedPingMessage)];\r\n                    case 2:\r\n                        _b.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        _a = _b.sent();\r\n                        // We don't care about the error. It should be seen elsewhere in the client.\r\n                        // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\r\n                        this.cleanupPingTimer();\r\n                        return [3 /*break*/, 4];\r\n                    case 4: return [2 /*return*/];\r\n                }\r\n            });\r\n        }); }, this.keepAliveIntervalInMilliseconds);\r\n    };\r\n    HubConnection.prototype.resetTimeoutPeriod = function () {\r\n        var _this = this;\r\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\r\n            // Set the timeout timer\r\n            this.timeoutHandle = setTimeout(function () { return _this.serverTimeout(); }, this.serverTimeoutInMilliseconds);\r\n        }\r\n    };\r\n    HubConnection.prototype.serverTimeout = function () {\r\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\r\n        // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\r\n        // tslint:disable-next-line:no-floating-promises\r\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\r\n    };\r\n    HubConnection.prototype.invokeClientMethod = function (invocationMessage) {\r\n        var _this = this;\r\n        var methods = this.methods[invocationMessage.target.toLowerCase()];\r\n        if (methods) {\r\n            try {\r\n                methods.forEach(function (m) { return m.apply(_this, invocationMessage.arguments); });\r\n            }\r\n            catch (e) {\r\n                this.logger.log(ILogger_1.LogLevel.Error, \"A callback for the method \" + invocationMessage.target.toLowerCase() + \" threw error '\" + e + \"'.\");\r\n            }\r\n            if (invocationMessage.invocationId) {\r\n                // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\r\n                var message = \"Server requested a response, which is not supported in this version of the client.\";\r\n                this.logger.log(ILogger_1.LogLevel.Error, message);\r\n                // We don't want to wait on the stop itself.\r\n                this.stopPromise = this.stopInternal(new Error(message));\r\n            }\r\n        }\r\n        else {\r\n            this.logger.log(ILogger_1.LogLevel.Warning, \"No client method with the name '\" + invocationMessage.target + \"' found.\");\r\n        }\r\n    };\r\n    HubConnection.prototype.connectionClosed = function (error) {\r\n        this.logger.log(ILogger_1.LogLevel.Debug, \"HubConnection.connectionClosed(\" + error + \") called while in state \" + this.connectionState + \".\");\r\n        // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\r\n        this.stopDuringStartError = this.stopDuringStartError || error || new Error(\"The underlying connection was closed before the hub handshake could complete.\");\r\n        // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\r\n        // If it has already completed, this should just noop.\r\n        if (this.handshakeResolver) {\r\n            this.handshakeResolver();\r\n        }\r\n        this.cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\r\n        this.cleanupTimeout();\r\n        this.cleanupPingTimer();\r\n        if (this.connectionState === HubConnectionState.Disconnecting) {\r\n            this.completeClose(error);\r\n        }\r\n        else if (this.connectionState === HubConnectionState.Connected && this.reconnectPolicy) {\r\n            // tslint:disable-next-line:no-floating-promises\r\n            this.reconnect(error);\r\n        }\r\n        else if (this.connectionState === HubConnectionState.Connected) {\r\n            this.completeClose(error);\r\n        }\r\n        // If none of the above if conditions were true were called the HubConnection must be in either:\r\n        // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\r\n        // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\r\n        //    and potentially continue the reconnect() loop.\r\n        // 3. The Disconnected state in which case we're already done.\r\n    };\r\n    HubConnection.prototype.completeClose = function (error) {\r\n        var _this = this;\r\n        if (this.connectionStarted) {\r\n            this.connectionState = HubConnectionState.Disconnected;\r\n            this.connectionStarted = false;\r\n            try {\r\n                this.closedCallbacks.forEach(function (c) { return c.apply(_this, [error]); });\r\n            }\r\n            catch (e) {\r\n                this.logger.log(ILogger_1.LogLevel.Error, \"An onclose callback called with error '\" + error + \"' threw error '\" + e + \"'.\");\r\n            }\r\n        }\r\n    };\r\n    HubConnection.prototype.reconnect = function (error) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var reconnectStartTime, previousReconnectAttempts, retryError, nextRetryDelay, e_4;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        reconnectStartTime = Date.now();\r\n                        previousReconnectAttempts = 0;\r\n                        retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\r\n                        nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\r\n                        if (nextRetryDelay === null) {\r\n                            this.logger.log(ILogger_1.LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\r\n                            this.completeClose(error);\r\n                            return [2 /*return*/];\r\n                        }\r\n                        this.connectionState = HubConnectionState.Reconnecting;\r\n                        if (error) {\r\n                            this.logger.log(ILogger_1.LogLevel.Information, \"Connection reconnecting because of error '\" + error + \"'.\");\r\n                        }\r\n                        else {\r\n                            this.logger.log(ILogger_1.LogLevel.Information, \"Connection reconnecting.\");\r\n                        }\r\n                        if (this.onreconnecting) {\r\n                            try {\r\n                                this.reconnectingCallbacks.forEach(function (c) { return c.apply(_this, [error]); });\r\n                            }\r\n                            catch (e) {\r\n                                this.logger.log(ILogger_1.LogLevel.Error, \"An onreconnecting callback called with error '\" + error + \"' threw error '\" + e + \"'.\");\r\n                            }\r\n                            // Exit early if an onreconnecting callback called connection.stop().\r\n                            if (this.connectionState !== HubConnectionState.Reconnecting) {\r\n                                this.logger.log(ILogger_1.LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\r\n                                return [2 /*return*/];\r\n                            }\r\n                        }\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        if (!(nextRetryDelay !== null)) return [3 /*break*/, 7];\r\n                        this.logger.log(ILogger_1.LogLevel.Information, \"Reconnect attempt number \" + previousReconnectAttempts + \" will start in \" + nextRetryDelay + \" ms.\");\r\n                        return [4 /*yield*/, new Promise(function (resolve) {\r\n                                _this.reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);\r\n                            })];\r\n                    case 2:\r\n                        _a.sent();\r\n                        this.reconnectDelayHandle = undefined;\r\n                        if (this.connectionState !== HubConnectionState.Reconnecting) {\r\n                            this.logger.log(ILogger_1.LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\r\n                            return [2 /*return*/];\r\n                        }\r\n                        _a.label = 3;\r\n                    case 3:\r\n                        _a.trys.push([3, 5, , 6]);\r\n                        return [4 /*yield*/, this.startInternal()];\r\n                    case 4:\r\n                        _a.sent();\r\n                        this.connectionState = HubConnectionState.Connected;\r\n                        this.logger.log(ILogger_1.LogLevel.Information, \"HubConnection reconnected successfully.\");\r\n                        if (this.onreconnected) {\r\n                            try {\r\n                                this.reconnectedCallbacks.forEach(function (c) { return c.apply(_this, [_this.connection.connectionId]); });\r\n                            }\r\n                            catch (e) {\r\n                                this.logger.log(ILogger_1.LogLevel.Error, \"An onreconnected callback called with connectionId '\" + this.connection.connectionId + \"; threw error '\" + e + \"'.\");\r\n                            }\r\n                        }\r\n                        return [2 /*return*/];\r\n                    case 5:\r\n                        e_4 = _a.sent();\r\n                        this.logger.log(ILogger_1.LogLevel.Information, \"Reconnect attempt failed because of error '\" + e_4 + \"'.\");\r\n                        if (this.connectionState !== HubConnectionState.Reconnecting) {\r\n                            this.logger.log(ILogger_1.LogLevel.Debug, \"Connection left the reconnecting state during reconnect attempt. Done reconnecting.\");\r\n                            return [2 /*return*/];\r\n                        }\r\n                        retryError = e_4 instanceof Error ? e_4 : new Error(e_4.toString());\r\n                        nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\r\n                        return [3 /*break*/, 6];\r\n                    case 6: return [3 /*break*/, 1];\r\n                    case 7:\r\n                        this.logger.log(ILogger_1.LogLevel.Information, \"Reconnect retries have been exhausted after \" + (Date.now() - reconnectStartTime) + \" ms and \" + previousReconnectAttempts + \" failed attempts. Connection disconnecting.\");\r\n                        this.completeClose();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HubConnection.prototype.getNextRetryDelay = function (previousRetryCount, elapsedMilliseconds, retryReason) {\r\n        try {\r\n            return this.reconnectPolicy.nextRetryDelayInMilliseconds({\r\n                elapsedMilliseconds: elapsedMilliseconds,\r\n                previousRetryCount: previousRetryCount,\r\n                retryReason: retryReason,\r\n            });\r\n        }\r\n        catch (e) {\r\n            this.logger.log(ILogger_1.LogLevel.Error, \"IRetryPolicy.nextRetryDelayInMilliseconds(\" + previousRetryCount + \", \" + elapsedMilliseconds + \") threw error '\" + e + \"'.\");\r\n            return null;\r\n        }\r\n    };\r\n    HubConnection.prototype.cancelCallbacksWithError = function (error) {\r\n        var callbacks = this.callbacks;\r\n        this.callbacks = {};\r\n        Object.keys(callbacks)\r\n            .forEach(function (key) {\r\n            var callback = callbacks[key];\r\n            callback(null, error);\r\n        });\r\n    };\r\n    HubConnection.prototype.cleanupPingTimer = function () {\r\n        if (this.pingServerHandle) {\r\n            clearTimeout(this.pingServerHandle);\r\n        }\r\n    };\r\n    HubConnection.prototype.cleanupTimeout = function () {\r\n        if (this.timeoutHandle) {\r\n            clearTimeout(this.timeoutHandle);\r\n        }\r\n    };\r\n    HubConnection.prototype.createInvocation = function (methodName, args, nonblocking, streamIds) {\r\n        if (nonblocking) {\r\n            return {\r\n                arguments: args,\r\n                streamIds: streamIds,\r\n                target: methodName,\r\n                type: IHubProtocol_1.MessageType.Invocation,\r\n            };\r\n        }\r\n        else {\r\n            var invocationId = this.invocationId;\r\n            this.invocationId++;\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                streamIds: streamIds,\r\n                target: methodName,\r\n                type: IHubProtocol_1.MessageType.Invocation,\r\n            };\r\n        }\r\n    };\r\n    HubConnection.prototype.launchStreams = function (streams, promiseQueue) {\r\n        var _this = this;\r\n        if (streams.length === 0) {\r\n            return;\r\n        }\r\n        // Synchronize stream data so they arrive in-order on the server\r\n        if (!promiseQueue) {\r\n            promiseQueue = Promise.resolve();\r\n        }\r\n        var _loop_1 = function (streamId) {\r\n            streams[streamId].subscribe({\r\n                complete: function () {\r\n                    promiseQueue = promiseQueue.then(function () { return _this.sendWithProtocol(_this.createCompletionMessage(streamId)); });\r\n                },\r\n                error: function (err) {\r\n                    var message;\r\n                    if (err instanceof Error) {\r\n                        message = err.message;\r\n                    }\r\n                    else if (err && err.toString) {\r\n                        message = err.toString();\r\n                    }\r\n                    else {\r\n                        message = \"Unknown error\";\r\n                    }\r\n                    promiseQueue = promiseQueue.then(function () { return _this.sendWithProtocol(_this.createCompletionMessage(streamId, message)); });\r\n                },\r\n                next: function (item) {\r\n                    promiseQueue = promiseQueue.then(function () { return _this.sendWithProtocol(_this.createStreamItemMessage(streamId, item)); });\r\n                },\r\n            });\r\n        };\r\n        // We want to iterate over the keys, since the keys are the stream ids\r\n        // tslint:disable-next-line:forin\r\n        for (var streamId in streams) {\r\n            _loop_1(streamId);\r\n        }\r\n    };\r\n    HubConnection.prototype.replaceStreamingParams = function (args) {\r\n        var streams = [];\r\n        var streamIds = [];\r\n        for (var i = 0; i < args.length; i++) {\r\n            var argument = args[i];\r\n            if (this.isObservable(argument)) {\r\n                var streamId = this.invocationId;\r\n                this.invocationId++;\r\n                // Store the stream for later use\r\n                streams[streamId] = argument;\r\n                streamIds.push(streamId.toString());\r\n                // remove stream from args\r\n                args.splice(i, 1);\r\n            }\r\n        }\r\n        return [streams, streamIds];\r\n    };\r\n    HubConnection.prototype.isObservable = function (arg) {\r\n        // This allows other stream implementations to just work (like rxjs)\r\n        return arg && arg.subscribe && typeof arg.subscribe === \"function\";\r\n    };\r\n    HubConnection.prototype.createStreamInvocation = function (methodName, args, streamIds) {\r\n        var invocationId = this.invocationId;\r\n        this.invocationId++;\r\n        return {\r\n            arguments: args,\r\n            invocationId: invocationId.toString(),\r\n            streamIds: streamIds,\r\n            target: methodName,\r\n            type: IHubProtocol_1.MessageType.StreamInvocation,\r\n        };\r\n    };\r\n    HubConnection.prototype.createCancelInvocation = function (id) {\r\n        return {\r\n            invocationId: id,\r\n            type: IHubProtocol_1.MessageType.CancelInvocation,\r\n        };\r\n    };\r\n    HubConnection.prototype.createStreamItemMessage = function (id, item) {\r\n        return {\r\n            invocationId: id,\r\n            item: item,\r\n            type: IHubProtocol_1.MessageType.StreamItem,\r\n        };\r\n    };\r\n    HubConnection.prototype.createCompletionMessage = function (id, error, result) {\r\n        if (error) {\r\n            return {\r\n                error: error,\r\n                invocationId: id,\r\n                type: IHubProtocol_1.MessageType.Completion,\r\n            };\r\n        }\r\n        return {\r\n            invocationId: id,\r\n            result: result,\r\n            type: IHubProtocol_1.MessageType.Completion,\r\n        };\r\n    };\r\n    return HubConnection;\r\n}());\r\nexports.HubConnection = HubConnection;\r\n//# sourceMappingURL=HubConnection.js.map","\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TextMessageFormat_1 = require(\"./TextMessageFormat\");\r\nvar Utils_1 = require(\"./Utils\");\r\n/** @private */\r\nvar HandshakeProtocol = /** @class */ (function () {\r\n    function HandshakeProtocol() {\r\n    }\r\n    // Handshake request is always JSON\r\n    HandshakeProtocol.prototype.writeHandshakeRequest = function (handshakeRequest) {\r\n        return TextMessageFormat_1.TextMessageFormat.write(JSON.stringify(handshakeRequest));\r\n    };\r\n    HandshakeProtocol.prototype.parseHandshakeResponse = function (data) {\r\n        var responseMessage;\r\n        var messageData;\r\n        var remainingData;\r\n        if (Utils_1.isArrayBuffer(data) || (typeof Buffer !== \"undefined\" && data instanceof Buffer)) {\r\n            // Format is binary but still need to read JSON text from handshake response\r\n            var binaryData = new Uint8Array(data);\r\n            var separatorIndex = binaryData.indexOf(TextMessageFormat_1.TextMessageFormat.RecordSeparatorCode);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            var responseLength = separatorIndex + 1;\r\n            messageData = String.fromCharCode.apply(null, binaryData.slice(0, responseLength));\r\n            remainingData = (binaryData.byteLength > responseLength) ? binaryData.slice(responseLength).buffer : null;\r\n        }\r\n        else {\r\n            var textData = data;\r\n            var separatorIndex = textData.indexOf(TextMessageFormat_1.TextMessageFormat.RecordSeparator);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            var responseLength = separatorIndex + 1;\r\n            messageData = textData.substring(0, responseLength);\r\n            remainingData = (textData.length > responseLength) ? textData.substring(responseLength) : null;\r\n        }\r\n        // At this point we should have just the single handshake message\r\n        var messages = TextMessageFormat_1.TextMessageFormat.parse(messageData);\r\n        var response = JSON.parse(messages[0]);\r\n        if (response.type) {\r\n            throw new Error(\"Expected a handshake response from the server.\");\r\n        }\r\n        responseMessage = response;\r\n        // multiple messages could have arrived with handshake\r\n        // return additional data to be parsed as usual, or null if all parsed\r\n        return [remainingData, responseMessage];\r\n    };\r\n    return HandshakeProtocol;\r\n}());\r\nexports.HandshakeProtocol = HandshakeProtocol;\r\n//# sourceMappingURL=HandshakeProtocol.js.map","\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Not exported from index\r\n/** @private */\r\nvar TextMessageFormat = /** @class */ (function () {\r\n    function TextMessageFormat() {\r\n    }\r\n    TextMessageFormat.write = function (output) {\r\n        return \"\" + output + TextMessageFormat.RecordSeparator;\r\n    };\r\n    TextMessageFormat.parse = function (input) {\r\n        if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\r\n            throw new Error(\"Message is incomplete.\");\r\n        }\r\n        var messages = input.split(TextMessageFormat.RecordSeparator);\r\n        messages.pop();\r\n        return messages;\r\n    };\r\n    TextMessageFormat.RecordSeparatorCode = 0x1e;\r\n    TextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);\r\n    return TextMessageFormat;\r\n}());\r\nexports.TextMessageFormat = TextMessageFormat;\r\n//# sourceMappingURL=TextMessageFormat.js.map","\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ILogger_1 = require(\"./ILogger\");\r\nvar Loggers_1 = require(\"./Loggers\");\r\n/** @private */\r\nvar Arg = /** @class */ (function () {\r\n    function Arg() {\r\n    }\r\n    Arg.isRequired = function (val, name) {\r\n        if (val === null || val === undefined) {\r\n            throw new Error(\"The '\" + name + \"' argument is required.\");\r\n        }\r\n    };\r\n    Arg.isIn = function (val, values, name) {\r\n        // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\r\n        if (!(val in values)) {\r\n            throw new Error(\"Unknown \" + name + \" value: \" + val + \".\");\r\n        }\r\n    };\r\n    return Arg;\r\n}());\r\nexports.Arg = Arg;\r\n/** @private */\r\nvar Platform = /** @class */ (function () {\r\n    function Platform() {\r\n    }\r\n    Object.defineProperty(Platform, \"isBrowser\", {\r\n        get: function () {\r\n            return typeof window === \"object\";\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Platform, \"isWebWorker\", {\r\n        get: function () {\r\n            return typeof self === \"object\" && \"importScripts\" in self;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Platform, \"isNode\", {\r\n        get: function () {\r\n            return !this.isBrowser && !this.isWebWorker;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return Platform;\r\n}());\r\nexports.Platform = Platform;\r\n/** @private */\r\nfunction getDataDetail(data, includeContent) {\r\n    var detail = \"\";\r\n    if (isArrayBuffer(data)) {\r\n        detail = \"Binary data of length \" + data.byteLength;\r\n        if (includeContent) {\r\n            detail += \". Content: '\" + formatArrayBuffer(data) + \"'\";\r\n        }\r\n    }\r\n    else if (typeof data === \"string\") {\r\n        detail = \"String data of length \" + data.length;\r\n        if (includeContent) {\r\n            detail += \". Content: '\" + data + \"'\";\r\n        }\r\n    }\r\n    return detail;\r\n}\r\nexports.getDataDetail = getDataDetail;\r\n/** @private */\r\nfunction formatArrayBuffer(data) {\r\n    var view = new Uint8Array(data);\r\n    // Uint8Array.map only supports returning another Uint8Array?\r\n    var str = \"\";\r\n    view.forEach(function (num) {\r\n        var pad = num < 16 ? \"0\" : \"\";\r\n        str += \"0x\" + pad + num.toString(16) + \" \";\r\n    });\r\n    // Trim of trailing space.\r\n    return str.substr(0, str.length - 1);\r\n}\r\nexports.formatArrayBuffer = formatArrayBuffer;\r\n// Also in signalr-protocol-msgpack/Utils.ts\r\n/** @private */\r\nfunction isArrayBuffer(val) {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n            (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}\r\nexports.isArrayBuffer = isArrayBuffer;\r\n/** @private */\r\nfunction sendMessage(logger, transportName, httpClient, url, accessTokenFactory, content, logMessageContent) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var headers, token, responseType, response;\r\n        var _a;\r\n        return __generator(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0:\r\n                    if (!accessTokenFactory) return [3 /*break*/, 2];\r\n                    return [4 /*yield*/, accessTokenFactory()];\r\n                case 1:\r\n                    token = _b.sent();\r\n                    if (token) {\r\n                        headers = (_a = {},\r\n                            _a[\"Authorization\"] = \"Bearer \" + token,\r\n                            _a);\r\n                    }\r\n                    _b.label = 2;\r\n                case 2:\r\n                    logger.log(ILogger_1.LogLevel.Trace, \"(\" + transportName + \" transport) sending data. \" + getDataDetail(content, logMessageContent) + \".\");\r\n                    responseType = isArrayBuffer(content) ? \"arraybuffer\" : \"text\";\r\n                    return [4 /*yield*/, httpClient.post(url, {\r\n                            content: content,\r\n                            headers: headers,\r\n                            responseType: responseType,\r\n                        })];\r\n                case 3:\r\n                    response = _b.sent();\r\n                    logger.log(ILogger_1.LogLevel.Trace, \"(\" + transportName + \" transport) request complete. Response status: \" + response.statusCode + \".\");\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.sendMessage = sendMessage;\r\n/** @private */\r\nfunction createLogger(logger) {\r\n    if (logger === undefined) {\r\n        return new ConsoleLogger(ILogger_1.LogLevel.Information);\r\n    }\r\n    if (logger === null) {\r\n        return Loggers_1.NullLogger.instance;\r\n    }\r\n    if (logger.log) {\r\n        return logger;\r\n    }\r\n    return new ConsoleLogger(logger);\r\n}\r\nexports.createLogger = createLogger;\r\n/** @private */\r\nvar SubjectSubscription = /** @class */ (function () {\r\n    function SubjectSubscription(subject, observer) {\r\n        this.subject = subject;\r\n        this.observer = observer;\r\n    }\r\n    SubjectSubscription.prototype.dispose = function () {\r\n        var index = this.subject.observers.indexOf(this.observer);\r\n        if (index > -1) {\r\n            this.subject.observers.splice(index, 1);\r\n        }\r\n        if (this.subject.observers.length === 0 && this.subject.cancelCallback) {\r\n            this.subject.cancelCallback().catch(function (_) { });\r\n        }\r\n    };\r\n    return SubjectSubscription;\r\n}());\r\nexports.SubjectSubscription = SubjectSubscription;\r\n/** @private */\r\nvar ConsoleLogger = /** @class */ (function () {\r\n    function ConsoleLogger(minimumLogLevel) {\r\n        this.minimumLogLevel = minimumLogLevel;\r\n        this.outputConsole = console;\r\n    }\r\n    ConsoleLogger.prototype.log = function (logLevel, message) {\r\n        if (logLevel >= this.minimumLogLevel) {\r\n            switch (logLevel) {\r\n                case ILogger_1.LogLevel.Critical:\r\n                case ILogger_1.LogLevel.Error:\r\n                    this.outputConsole.error(\"[\" + new Date().toISOString() + \"] \" + ILogger_1.LogLevel[logLevel] + \": \" + message);\r\n                    break;\r\n                case ILogger_1.LogLevel.Warning:\r\n                    this.outputConsole.warn(\"[\" + new Date().toISOString() + \"] \" + ILogger_1.LogLevel[logLevel] + \": \" + message);\r\n                    break;\r\n                case ILogger_1.LogLevel.Information:\r\n                    this.outputConsole.info(\"[\" + new Date().toISOString() + \"] \" + ILogger_1.LogLevel[logLevel] + \": \" + message);\r\n                    break;\r\n                default:\r\n                    // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\r\n                    this.outputConsole.log(\"[\" + new Date().toISOString() + \"] \" + ILogger_1.LogLevel[logLevel] + \": \" + message);\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n    return ConsoleLogger;\r\n}());\r\nexports.ConsoleLogger = ConsoleLogger;\r\n//# sourceMappingURL=Utils.js.map","\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** A logger that does nothing when log messages are sent to it. */\r\nvar NullLogger = /** @class */ (function () {\r\n    function NullLogger() {\r\n    }\r\n    /** @inheritDoc */\r\n    // tslint:disable-next-line\r\n    NullLogger.prototype.log = function (_logLevel, _message) {\r\n    };\r\n    /** The singleton instance of the {@link @microsoft/signalr.NullLogger}. */\r\n    NullLogger.instance = new NullLogger();\r\n    return NullLogger;\r\n}());\r\nexports.NullLogger = NullLogger;\r\n//# sourceMappingURL=Loggers.js.map","\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** Defines the type of a Hub Message. */\r\nvar MessageType;\r\n(function (MessageType) {\r\n    /** Indicates the message is an Invocation message and implements the {@link @microsoft/signalr.InvocationMessage} interface. */\r\n    MessageType[MessageType[\"Invocation\"] = 1] = \"Invocation\";\r\n    /** Indicates the message is a StreamItem message and implements the {@link @microsoft/signalr.StreamItemMessage} interface. */\r\n    MessageType[MessageType[\"StreamItem\"] = 2] = \"StreamItem\";\r\n    /** Indicates the message is a Completion message and implements the {@link @microsoft/signalr.CompletionMessage} interface. */\r\n    MessageType[MessageType[\"Completion\"] = 3] = \"Completion\";\r\n    /** Indicates the message is a Stream Invocation message and implements the {@link @microsoft/signalr.StreamInvocationMessage} interface. */\r\n    MessageType[MessageType[\"StreamInvocation\"] = 4] = \"StreamInvocation\";\r\n    /** Indicates the message is a Cancel Invocation message and implements the {@link @microsoft/signalr.CancelInvocationMessage} interface. */\r\n    MessageType[MessageType[\"CancelInvocation\"] = 5] = \"CancelInvocation\";\r\n    /** Indicates the message is a Ping message and implements the {@link @microsoft/signalr.PingMessage} interface. */\r\n    MessageType[MessageType[\"Ping\"] = 6] = \"Ping\";\r\n    /** Indicates the message is a Close message and implements the {@link @microsoft/signalr.CloseMessage} interface. */\r\n    MessageType[MessageType[\"Close\"] = 7] = \"Close\";\r\n})(MessageType = exports.MessageType || (exports.MessageType = {}));\r\n//# sourceMappingURL=IHubProtocol.js.map","\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Utils_1 = require(\"./Utils\");\r\n/** Stream implementation to stream items to the server. */\r\nvar Subject = /** @class */ (function () {\r\n    function Subject() {\r\n        this.observers = [];\r\n    }\r\n    Subject.prototype.next = function (item) {\r\n        for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {\r\n            var observer = _a[_i];\r\n            observer.next(item);\r\n        }\r\n    };\r\n    Subject.prototype.error = function (err) {\r\n        for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {\r\n            var observer = _a[_i];\r\n            if (observer.error) {\r\n                observer.error(err);\r\n            }\r\n        }\r\n    };\r\n    Subject.prototype.complete = function () {\r\n        for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {\r\n            var observer = _a[_i];\r\n            if (observer.complete) {\r\n                observer.complete();\r\n            }\r\n        }\r\n    };\r\n    Subject.prototype.subscribe = function (observer) {\r\n        this.observers.push(observer);\r\n        return new Utils_1.SubjectSubscription(this, observer);\r\n    };\r\n    return Subject;\r\n}());\r\nexports.Subject = Subject;\r\n//# sourceMappingURL=Subject.js.map","\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DefaultReconnectPolicy_1 = require(\"./DefaultReconnectPolicy\");\r\nvar HttpConnection_1 = require(\"./HttpConnection\");\r\nvar HubConnection_1 = require(\"./HubConnection\");\r\nvar ILogger_1 = require(\"./ILogger\");\r\nvar JsonHubProtocol_1 = require(\"./JsonHubProtocol\");\r\nvar Loggers_1 = require(\"./Loggers\");\r\nvar Utils_1 = require(\"./Utils\");\r\n// tslint:disable:object-literal-sort-keys\r\nvar LogLevelNameMapping = {\r\n    trace: ILogger_1.LogLevel.Trace,\r\n    debug: ILogger_1.LogLevel.Debug,\r\n    info: ILogger_1.LogLevel.Information,\r\n    information: ILogger_1.LogLevel.Information,\r\n    warn: ILogger_1.LogLevel.Warning,\r\n    warning: ILogger_1.LogLevel.Warning,\r\n    error: ILogger_1.LogLevel.Error,\r\n    critical: ILogger_1.LogLevel.Critical,\r\n    none: ILogger_1.LogLevel.None,\r\n};\r\nfunction parseLogLevel(name) {\r\n    // Case-insensitive matching via lower-casing\r\n    // Yes, I know case-folding is a complicated problem in Unicode, but we only support\r\n    // the ASCII strings defined in LogLevelNameMapping anyway, so it's fine -anurse.\r\n    var mapping = LogLevelNameMapping[name.toLowerCase()];\r\n    if (typeof mapping !== \"undefined\") {\r\n        return mapping;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown log level: \" + name);\r\n    }\r\n}\r\n/** A builder for configuring {@link @microsoft/signalr.HubConnection} instances. */\r\nvar HubConnectionBuilder = /** @class */ (function () {\r\n    function HubConnectionBuilder() {\r\n    }\r\n    HubConnectionBuilder.prototype.configureLogging = function (logging) {\r\n        Utils_1.Arg.isRequired(logging, \"logging\");\r\n        if (isLogger(logging)) {\r\n            this.logger = logging;\r\n        }\r\n        else if (typeof logging === \"string\") {\r\n            var logLevel = parseLogLevel(logging);\r\n            this.logger = new Utils_1.ConsoleLogger(logLevel);\r\n        }\r\n        else {\r\n            this.logger = new Utils_1.ConsoleLogger(logging);\r\n        }\r\n        return this;\r\n    };\r\n    HubConnectionBuilder.prototype.withUrl = function (url, transportTypeOrOptions) {\r\n        Utils_1.Arg.isRequired(url, \"url\");\r\n        this.url = url;\r\n        // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed\r\n        // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.\r\n        if (typeof transportTypeOrOptions === \"object\") {\r\n            this.httpConnectionOptions = __assign(__assign({}, this.httpConnectionOptions), transportTypeOrOptions);\r\n        }\r\n        else {\r\n            this.httpConnectionOptions = __assign(__assign({}, this.httpConnectionOptions), { transport: transportTypeOrOptions });\r\n        }\r\n        return this;\r\n    };\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.\r\n     *\r\n     * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.\r\n     */\r\n    HubConnectionBuilder.prototype.withHubProtocol = function (protocol) {\r\n        Utils_1.Arg.isRequired(protocol, \"protocol\");\r\n        this.protocol = protocol;\r\n        return this;\r\n    };\r\n    HubConnectionBuilder.prototype.withAutomaticReconnect = function (retryDelaysOrReconnectPolicy) {\r\n        if (this.reconnectPolicy) {\r\n            throw new Error(\"A reconnectPolicy has already been set.\");\r\n        }\r\n        if (!retryDelaysOrReconnectPolicy) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy_1.DefaultReconnectPolicy();\r\n        }\r\n        else if (Array.isArray(retryDelaysOrReconnectPolicy)) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy_1.DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);\r\n        }\r\n        else {\r\n            this.reconnectPolicy = retryDelaysOrReconnectPolicy;\r\n        }\r\n        return this;\r\n    };\r\n    /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.\r\n     *\r\n     * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.\r\n     */\r\n    HubConnectionBuilder.prototype.build = function () {\r\n        // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one\r\n        // provided to configureLogger\r\n        var httpConnectionOptions = this.httpConnectionOptions || {};\r\n        // If it's 'null', the user **explicitly** asked for null, don't mess with it.\r\n        if (httpConnectionOptions.logger === undefined) {\r\n            // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.\r\n            httpConnectionOptions.logger = this.logger;\r\n        }\r\n        // Now create the connection\r\n        if (!this.url) {\r\n            throw new Error(\"The 'HubConnectionBuilder.withUrl' method must be called before building the connection.\");\r\n        }\r\n        var connection = new HttpConnection_1.HttpConnection(this.url, httpConnectionOptions);\r\n        return HubConnection_1.HubConnection.create(connection, this.logger || Loggers_1.NullLogger.instance, this.protocol || new JsonHubProtocol_1.JsonHubProtocol(), this.reconnectPolicy);\r\n    };\r\n    return HubConnectionBuilder;\r\n}());\r\nexports.HubConnectionBuilder = HubConnectionBuilder;\r\nfunction isLogger(logger) {\r\n    return logger.log !== undefined;\r\n}\r\n//# sourceMappingURL=HubConnectionBuilder.js.map","\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// 0, 2, 10, 30 second delays before reconnect attempts.\r\nvar DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2000, 10000, 30000, null];\r\n/** @private */\r\nvar DefaultReconnectPolicy = /** @class */ (function () {\r\n    function DefaultReconnectPolicy(retryDelays) {\r\n        this.retryDelays = retryDelays !== undefined ? __spreadArrays(retryDelays, [null]) : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;\r\n    }\r\n    DefaultReconnectPolicy.prototype.nextRetryDelayInMilliseconds = function (retryContext) {\r\n        return this.retryDelays[retryContext.previousRetryCount];\r\n    };\r\n    return DefaultReconnectPolicy;\r\n}());\r\nexports.DefaultReconnectPolicy = DefaultReconnectPolicy;\r\n//# sourceMappingURL=DefaultReconnectPolicy.js.map","\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DefaultHttpClient_1 = require(\"./DefaultHttpClient\");\r\nvar ILogger_1 = require(\"./ILogger\");\r\nvar ITransport_1 = require(\"./ITransport\");\r\nvar Utils_1 = require(\"./Utils\");\r\nvar WeChatWebSocketTransport_1 = require(\"./WeChatWebSocketTransport\");\r\nvar MAX_REDIRECTS = 100;\r\n// let WebSocketModule: any = null;\r\n// let EventSourceModule: any = null;\r\nif (Utils_1.Platform.isNode && typeof require !== \"undefined\") {\r\n    // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n    // @ts-ignore: TS doesn't know about these names\r\n    // const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n    // WebSocketModule = requireFunc(\"ws\");\r\n    // EventSourceModule = requireFunc(\"eventsource\");\r\n}\r\n/** @private */\r\nvar HttpConnection = /** @class */ (function () {\r\n    function HttpConnection(url, options) {\r\n        if (options === void 0) { options = {}; }\r\n        this.features = {};\r\n        Utils_1.Arg.isRequired(url, \"url\");\r\n        this.logger = Utils_1.createLogger(options.logger);\r\n        this.baseUrl = this.resolveUrl(url);\r\n        options = options || {};\r\n        options.logMessageContent = options.logMessageContent || false;\r\n        if (!Utils_1.Platform.isNode && typeof wx.connectSocket !== \"undefined\" && !options.WebSocket) {\r\n            // options.WebSocket = WebSocket; // no need this\r\n        }\r\n        else if (Utils_1.Platform.isNode && !options.WebSocket) {\r\n            // if (WebSocketModule) {\r\n            //     options.WebSocket = WebSocketModule;\r\n            // }\r\n        }\r\n        options.WebSocket = (function () { }); // websocket detect support\r\n        // if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\r\n        //     options.EventSource = EventSource;\r\n        // } else if (Platform.isNode && !options.EventSource) {\r\n        //     if (typeof EventSourceModule !== \"undefined\") {\r\n        //         options.EventSource = EventSourceModule;\r\n        //     }\r\n        // }\r\n        this.httpClient = options.httpClient || new DefaultHttpClient_1.DefaultHttpClient(this.logger);\r\n        this.connectionState = \"Disconnected\" /* Disconnected */;\r\n        this.connectionStarted = false;\r\n        this.options = options;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    HttpConnection.prototype.start = function (transferFormat) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var message, message;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        transferFormat = transferFormat || ITransport_1.TransferFormat.Binary;\r\n                        Utils_1.Arg.isIn(transferFormat, ITransport_1.TransferFormat, \"transferFormat\");\r\n                        this.logger.log(ILogger_1.LogLevel.Debug, \"Starting connection with transfer format '\" + ITransport_1.TransferFormat[transferFormat] + \"'.\");\r\n                        if (this.connectionState !== \"Disconnected\" /* Disconnected */) {\r\n                            return [2 /*return*/, Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"))];\r\n                        }\r\n                        this.connectionState = \"Connecting \" /* Connecting */;\r\n                        this.startInternalPromise = this.startInternal(transferFormat);\r\n                        return [4 /*yield*/, this.startInternalPromise];\r\n                    case 1:\r\n                        _a.sent();\r\n                        if (!(this.connectionState === \"Disconnecting\" /* Disconnecting */)) return [3 /*break*/, 3];\r\n                        message = \"Failed to start the HttpConnection before stop() was called.\";\r\n                        this.logger.log(ILogger_1.LogLevel.Error, message);\r\n                        // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\r\n                        return [4 /*yield*/, this.stopPromise];\r\n                    case 2:\r\n                        // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\r\n                        _a.sent();\r\n                        return [2 /*return*/, Promise.reject(new Error(message))];\r\n                    case 3:\r\n                        if (this.connectionState !== \"Connected\" /* Connected */) {\r\n                            message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\r\n                            this.logger.log(ILogger_1.LogLevel.Error, message);\r\n                            return [2 /*return*/, Promise.reject(new Error(message))];\r\n                        }\r\n                        _a.label = 4;\r\n                    case 4:\r\n                        this.connectionStarted = true;\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpConnection.prototype.send = function (data) {\r\n        if (this.connectionState !== \"Connected\" /* Connected */) {\r\n            return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\r\n        }\r\n        if (!this.sendQueue) {\r\n            this.sendQueue = new TransportSendQueue(this.transport);\r\n        }\r\n        // Transport will not be null if state is connected\r\n        return this.sendQueue.send(data);\r\n    };\r\n    HttpConnection.prototype.stop = function (error) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (this.connectionState === \"Disconnected\" /* Disconnected */) {\r\n                            this.logger.log(ILogger_1.LogLevel.Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnected state.\");\r\n                            return [2 /*return*/, Promise.resolve()];\r\n                        }\r\n                        if (this.connectionState === \"Disconnecting\" /* Disconnecting */) {\r\n                            this.logger.log(ILogger_1.LogLevel.Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnecting state.\");\r\n                            return [2 /*return*/, this.stopPromise];\r\n                        }\r\n                        this.connectionState = \"Disconnecting\" /* Disconnecting */;\r\n                        this.stopPromise = new Promise(function (resolve) {\r\n                            // Don't complete stop() until stopConnection() completes.\r\n                            _this.stopPromiseResolver = resolve;\r\n                        });\r\n                        // stopInternal should never throw so just observe it.\r\n                        return [4 /*yield*/, this.stopInternal(error)];\r\n                    case 1:\r\n                        // stopInternal should never throw so just observe it.\r\n                        _a.sent();\r\n                        return [4 /*yield*/, this.stopPromise];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpConnection.prototype.stopInternal = function (error) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var e_1, e_2, e_3;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        // Set error as soon as possible otherwise there is a race between\r\n                        // the transport closing and providing an error and the error from a close message\r\n                        // We would prefer the close message error.\r\n                        this.stopError = error;\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, this.startInternalPromise];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        e_1 = _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 4:\r\n                        if (!this.sendQueue) return [3 /*break*/, 9];\r\n                        _a.label = 5;\r\n                    case 5:\r\n                        _a.trys.push([5, 7, , 8]);\r\n                        return [4 /*yield*/, this.sendQueue.stop()];\r\n                    case 6:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 8];\r\n                    case 7:\r\n                        e_2 = _a.sent();\r\n                        this.logger.log(ILogger_1.LogLevel.Error, \"TransportSendQueue.stop() threw error '\" + e_2 + \"'.\");\r\n                        return [3 /*break*/, 8];\r\n                    case 8:\r\n                        this.sendQueue = undefined;\r\n                        _a.label = 9;\r\n                    case 9:\r\n                        if (!this.transport) return [3 /*break*/, 14];\r\n                        _a.label = 10;\r\n                    case 10:\r\n                        _a.trys.push([10, 12, , 13]);\r\n                        return [4 /*yield*/, this.transport.stop()];\r\n                    case 11:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 13];\r\n                    case 12:\r\n                        e_3 = _a.sent();\r\n                        this.logger.log(ILogger_1.LogLevel.Error, \"HttpConnection.transport.stop() threw error '\" + e_3 + \"'.\");\r\n                        this.stopConnection();\r\n                        return [3 /*break*/, 13];\r\n                    case 13:\r\n                        this.transport = undefined;\r\n                        return [3 /*break*/, 15];\r\n                    case 14:\r\n                        this.logger.log(ILogger_1.LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\r\n                        this.stopConnection();\r\n                        _a.label = 15;\r\n                    case 15: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpConnection.prototype.startInternal = function (transferFormat) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, negotiateResponse, redirects, _loop_1, this_1, e_4;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = this.baseUrl;\r\n                        this.accessTokenFactory = this.options.accessTokenFactory;\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 12, , 13]);\r\n                        if (!this.options.skipNegotiation) return [3 /*break*/, 5];\r\n                        if (!(this.options.transport === ITransport_1.HttpTransportType.WebSockets)) return [3 /*break*/, 3];\r\n                        // No need to add a connection ID in this case\r\n                        this.transport = this.constructTransport(ITransport_1.HttpTransportType.WebSockets);\r\n                        // We should just call connect directly in this case.\r\n                        // No fallback or negotiate in this case.\r\n                        return [4 /*yield*/, this.startTransport(url, transferFormat)];\r\n                    case 2:\r\n                        // We should just call connect directly in this case.\r\n                        // No fallback or negotiate in this case.\r\n                        _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3: throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\r\n                    case 4: return [3 /*break*/, 11];\r\n                    case 5:\r\n                        negotiateResponse = null;\r\n                        redirects = 0;\r\n                        _loop_1 = function () {\r\n                            var accessToken_1;\r\n                            return __generator(this, function (_a) {\r\n                                switch (_a.label) {\r\n                                    case 0: return [4 /*yield*/, this_1.getNegotiationResponse(url)];\r\n                                    case 1:\r\n                                        negotiateResponse = _a.sent();\r\n                                        // the user tries to stop the connection when it is being started\r\n                                        if (this_1.connectionState === \"Disconnecting\" /* Disconnecting */ || this_1.connectionState === \"Disconnected\" /* Disconnected */) {\r\n                                            throw new Error(\"The connection was stopped during negotiation.\");\r\n                                        }\r\n                                        if (negotiateResponse.error) {\r\n                                            throw new Error(negotiateResponse.error);\r\n                                        }\r\n                                        if (negotiateResponse.ProtocolVersion) {\r\n                                            throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\r\n                                        }\r\n                                        if (negotiateResponse.url) {\r\n                                            url = negotiateResponse.url;\r\n                                        }\r\n                                        if (negotiateResponse.accessToken) {\r\n                                            accessToken_1 = negotiateResponse.accessToken;\r\n                                            this_1.accessTokenFactory = function () { return accessToken_1; };\r\n                                        }\r\n                                        redirects++;\r\n                                        return [2 /*return*/];\r\n                                }\r\n                            });\r\n                        };\r\n                        this_1 = this;\r\n                        _a.label = 6;\r\n                    case 6: return [5 /*yield**/, _loop_1()];\r\n                    case 7:\r\n                        _a.sent();\r\n                        _a.label = 8;\r\n                    case 8:\r\n                        if (negotiateResponse.url && redirects < MAX_REDIRECTS) return [3 /*break*/, 6];\r\n                        _a.label = 9;\r\n                    case 9:\r\n                        if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\r\n                            throw new Error(\"Negotiate redirection limit exceeded.\");\r\n                        }\r\n                        this.connectionId = negotiateResponse.connectionId;\r\n                        return [4 /*yield*/, this.createTransport(url, this.options.transport, negotiateResponse, transferFormat)];\r\n                    case 10:\r\n                        _a.sent();\r\n                        _a.label = 11;\r\n                    case 11:\r\n                        // if (this.transport instanceof LongPollingTransport) {\r\n                        //     this.features.inherentKeepAlive = true;\r\n                        // }\r\n                        if (this.connectionState === \"Connecting \" /* Connecting */) {\r\n                            // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\r\n                            // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\r\n                            this.logger.log(ILogger_1.LogLevel.Debug, \"The HttpConnection connected successfully.\");\r\n                            this.connectionState = \"Connected\" /* Connected */;\r\n                        }\r\n                        return [3 /*break*/, 13];\r\n                    case 12:\r\n                        e_4 = _a.sent();\r\n                        this.logger.log(ILogger_1.LogLevel.Error, \"Failed to start the connection: \" + e_4);\r\n                        this.connectionState = \"Disconnected\" /* Disconnected */;\r\n                        this.transport = undefined;\r\n                        return [2 /*return*/, Promise.reject(e_4)];\r\n                    case 13: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpConnection.prototype.getNegotiationResponse = function (url) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var headers, token, negotiateUrl, response, e_5;\r\n            var _a;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        if (!this.accessTokenFactory) return [3 /*break*/, 2];\r\n                        return [4 /*yield*/, this.accessTokenFactory()];\r\n                    case 1:\r\n                        token = _b.sent();\r\n                        if (token) {\r\n                            headers = (_a = {},\r\n                                _a[\"Authorization\"] = \"Bearer \" + token,\r\n                                _a);\r\n                        }\r\n                        _b.label = 2;\r\n                    case 2:\r\n                        negotiateUrl = this.resolveNegotiateUrl(url);\r\n                        this.logger.log(ILogger_1.LogLevel.Debug, \"Sending negotiation request: \" + negotiateUrl + \".\");\r\n                        _b.label = 3;\r\n                    case 3:\r\n                        _b.trys.push([3, 5, , 6]);\r\n                        return [4 /*yield*/, this.httpClient.post(negotiateUrl, {\r\n                                content: \"\",\r\n                                headers: headers,\r\n                            })];\r\n                    case 4:\r\n                        response = _b.sent();\r\n                        if (response.statusCode !== 200) {\r\n                            return [2 /*return*/, Promise.reject(new Error(\"Unexpected status code returned from negotiate \" + response.statusCode))];\r\n                        }\r\n                        return [2 /*return*/, JSON.parse(response.content)];\r\n                    case 5:\r\n                        e_5 = _b.sent();\r\n                        this.logger.log(ILogger_1.LogLevel.Error, \"Failed to complete negotiation with the server: \" + e_5);\r\n                        return [2 /*return*/, Promise.reject(e_5)];\r\n                    case 6: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpConnection.prototype.createConnectUrl = function (url, connectionId) {\r\n        if (!connectionId) {\r\n            return url;\r\n        }\r\n        return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + (\"id=\" + connectionId);\r\n    };\r\n    HttpConnection.prototype.createTransport = function (url, requestedTransport, negotiateResponse, requestedTransferFormat) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var connectUrl, transportExceptions, transports, _i, transports_1, endpoint, transportOrError, ex_1, ex_2, message;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        connectUrl = this.createConnectUrl(url, negotiateResponse.connectionId);\r\n                        if (!this.isITransport(requestedTransport)) return [3 /*break*/, 2];\r\n                        this.logger.log(ILogger_1.LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\r\n                        this.transport = requestedTransport;\r\n                        return [4 /*yield*/, this.startTransport(connectUrl, requestedTransferFormat)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                    case 2:\r\n                        transportExceptions = [];\r\n                        transports = negotiateResponse.availableTransports || [];\r\n                        _i = 0, transports_1 = transports;\r\n                        _a.label = 3;\r\n                    case 3:\r\n                        if (!(_i < transports_1.length)) return [3 /*break*/, 13];\r\n                        endpoint = transports_1[_i];\r\n                        transportOrError = this.resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\r\n                        if (!(transportOrError instanceof Error)) return [3 /*break*/, 4];\r\n                        // Store the error and continue, we don't want to cause a re-negotiate in these cases\r\n                        transportExceptions.push(endpoint.transport + \" failed: \" + transportOrError);\r\n                        return [3 /*break*/, 12];\r\n                    case 4:\r\n                        if (!this.isITransport(transportOrError)) return [3 /*break*/, 12];\r\n                        this.transport = transportOrError;\r\n                        if (!!negotiateResponse.connectionId) return [3 /*break*/, 9];\r\n                        _a.label = 5;\r\n                    case 5:\r\n                        _a.trys.push([5, 7, , 8]);\r\n                        return [4 /*yield*/, this.getNegotiationResponse(url)];\r\n                    case 6:\r\n                        negotiateResponse = _a.sent();\r\n                        return [3 /*break*/, 8];\r\n                    case 7:\r\n                        ex_1 = _a.sent();\r\n                        return [2 /*return*/, Promise.reject(ex_1)];\r\n                    case 8:\r\n                        connectUrl = this.createConnectUrl(url, negotiateResponse.connectionId);\r\n                        _a.label = 9;\r\n                    case 9:\r\n                        _a.trys.push([9, 11, , 12]);\r\n                        return [4 /*yield*/, this.startTransport(connectUrl, requestedTransferFormat)];\r\n                    case 10:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                    case 11:\r\n                        ex_2 = _a.sent();\r\n                        this.logger.log(ILogger_1.LogLevel.Error, \"Failed to start the transport '\" + endpoint.transport + \"': \" + ex_2);\r\n                        negotiateResponse.connectionId = undefined;\r\n                        transportExceptions.push(endpoint.transport + \" failed: \" + ex_2);\r\n                        if (this.connectionState !== \"Connecting \" /* Connecting */) {\r\n                            message = \"Failed to select transport before stop() was called.\";\r\n                            this.logger.log(ILogger_1.LogLevel.Debug, message);\r\n                            return [2 /*return*/, Promise.reject(new Error(message))];\r\n                        }\r\n                        return [3 /*break*/, 12];\r\n                    case 12:\r\n                        _i++;\r\n                        return [3 /*break*/, 3];\r\n                    case 13:\r\n                        if (transportExceptions.length > 0) {\r\n                            return [2 /*return*/, Promise.reject(new Error(\"Unable to connect to the server with any of the available transports. \" + transportExceptions.join(\" \")))];\r\n                        }\r\n                        return [2 /*return*/, Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"))];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpConnection.prototype.constructTransport = function (transport) {\r\n        switch (transport) {\r\n            case ITransport_1.HttpTransportType.WebSockets:\r\n                if (!this.options.WebSocket) {\r\n                    throw new Error(\"'WebSocket' is not supported in your environment.\");\r\n                }\r\n                return new WeChatWebSocketTransport_1.WeChatWebSocketTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false);\r\n            case ITransport_1.HttpTransportType.ServerSentEvents:\r\n                // if (!this.options.EventSource) {\r\n                //     throw new Error(\"'EventSource' is not supported in your environment.\");\r\n                // }\r\n                // return new ServerSentEventsTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.EventSource);\r\n                throw new Error(\"'EventSource' is not supported in your environment.\");\r\n            case ITransport_1.HttpTransportType.LongPolling:\r\n                // return new LongPollingTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false);\r\n                throw new Error(\"'LongPollingTransport' is current not implemented.\");\r\n            default:\r\n                throw new Error(\"Unknown transport: \" + transport + \".\");\r\n        }\r\n    };\r\n    HttpConnection.prototype.startTransport = function (url, transferFormat) {\r\n        var _this = this;\r\n        this.transport.onreceive = this.onreceive;\r\n        this.transport.onclose = function (e) { return _this.stopConnection(e); };\r\n        return this.transport.connect(url, transferFormat);\r\n    };\r\n    HttpConnection.prototype.resolveTransportOrError = function (endpoint, requestedTransport, requestedTransferFormat) {\r\n        var transport = ITransport_1.HttpTransportType[endpoint.transport];\r\n        if (transport === null || transport === undefined) {\r\n            this.logger.log(ILogger_1.LogLevel.Debug, \"Skipping transport '\" + endpoint.transport + \"' because it is not supported by this client.\");\r\n            return new Error(\"Skipping transport '\" + endpoint.transport + \"' because it is not supported by this client.\");\r\n        }\r\n        else {\r\n            if (transportMatches(requestedTransport, transport)) {\r\n                var transferFormats = endpoint.transferFormats.map(function (s) { return ITransport_1.TransferFormat[s]; });\r\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\r\n                    if ((transport === ITransport_1.HttpTransportType.WebSockets && !this.options.WebSocket) ||\r\n                        (transport === ITransport_1.HttpTransportType.ServerSentEvents && !this.options.EventSource)) {\r\n                        this.logger.log(ILogger_1.LogLevel.Debug, \"Skipping transport '\" + ITransport_1.HttpTransportType[transport] + \"' because it is not supported in your environment.'\");\r\n                        return new Error(\"'\" + ITransport_1.HttpTransportType[transport] + \"' is not supported in your environment.\");\r\n                    }\r\n                    else {\r\n                        this.logger.log(ILogger_1.LogLevel.Debug, \"Selecting transport '\" + ITransport_1.HttpTransportType[transport] + \"'.\");\r\n                        try {\r\n                            return this.constructTransport(transport);\r\n                        }\r\n                        catch (ex) {\r\n                            return ex;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    this.logger.log(ILogger_1.LogLevel.Debug, \"Skipping transport '\" + ITransport_1.HttpTransportType[transport] + \"' because it does not support the requested transfer format '\" + ITransport_1.TransferFormat[requestedTransferFormat] + \"'.\");\r\n                    return new Error(\"'\" + ITransport_1.HttpTransportType[transport] + \"' does not support \" + ITransport_1.TransferFormat[requestedTransferFormat] + \".\");\r\n                }\r\n            }\r\n            else {\r\n                this.logger.log(ILogger_1.LogLevel.Debug, \"Skipping transport '\" + ITransport_1.HttpTransportType[transport] + \"' because it was disabled by the client.\");\r\n                return new Error(\"'\" + ITransport_1.HttpTransportType[transport] + \"' is disabled by the client.\");\r\n            }\r\n        }\r\n    };\r\n    HttpConnection.prototype.isITransport = function (transport) {\r\n        return transport && typeof (transport) === \"object\" && \"connect\" in transport;\r\n    };\r\n    HttpConnection.prototype.stopConnection = function (error) {\r\n        this.logger.log(ILogger_1.LogLevel.Debug, \"HttpConnection.stopConnection(\" + error + \") called while in state \" + this.connectionState + \".\");\r\n        this.transport = undefined;\r\n        // If we have a stopError, it takes precedence over the error from the transport\r\n        error = this.stopError || error;\r\n        this.stopError = undefined;\r\n        if (this.connectionState === \"Disconnected\" /* Disconnected */) {\r\n            this.logger.log(ILogger_1.LogLevel.Debug, \"Call to HttpConnection.stopConnection(\" + error + \") was ignored because the connection is already in the disconnected state.\");\r\n            return;\r\n        }\r\n        if (this.connectionState === \"Connecting \" /* Connecting */) {\r\n            this.logger.log(ILogger_1.LogLevel.Warning, \"Call to HttpConnection.stopConnection(\" + error + \") was ignored because the connection hasn't yet left the in the connecting state.\");\r\n            return;\r\n        }\r\n        if (this.connectionState === \"Disconnecting\" /* Disconnecting */) {\r\n            // A call to stop() induced this call to stopConnection and needs to be completed.\r\n            // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\r\n            this.stopPromiseResolver();\r\n        }\r\n        if (error) {\r\n            this.logger.log(ILogger_1.LogLevel.Error, \"Connection disconnected with error '\" + error + \"'.\");\r\n        }\r\n        else {\r\n            this.logger.log(ILogger_1.LogLevel.Information, \"Connection disconnected.\");\r\n        }\r\n        this.connectionId = undefined;\r\n        this.connectionState = \"Disconnected\" /* Disconnected */;\r\n        if (this.onclose && this.connectionStarted) {\r\n            this.connectionStarted = false;\r\n            try {\r\n                this.onclose(error);\r\n            }\r\n            catch (e) {\r\n                this.logger.log(ILogger_1.LogLevel.Error, \"HttpConnection.onclose(\" + error + \") threw error '\" + e + \"'.\");\r\n            }\r\n        }\r\n    };\r\n    HttpConnection.prototype.resolveUrl = function (url) {\r\n        // startsWith is not supported in IE\r\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\r\n            return url;\r\n        }\r\n        throw new Error(\"Cannot resolve '\" + url + \"'.\");\r\n    };\r\n    HttpConnection.prototype.resolveNegotiateUrl = function (url) {\r\n        var index = url.indexOf(\"?\");\r\n        var negotiateUrl = url.substring(0, index === -1 ? url.length : index);\r\n        if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\r\n            negotiateUrl += \"/\";\r\n        }\r\n        negotiateUrl += \"negotiate\";\r\n        negotiateUrl += index === -1 ? \"\" : url.substring(index);\r\n        return negotiateUrl;\r\n    };\r\n    return HttpConnection;\r\n}());\r\nexports.HttpConnection = HttpConnection;\r\nfunction transportMatches(requestedTransport, actualTransport) {\r\n    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);\r\n}\r\nvar TransportSendQueue = /** @class */ (function () {\r\n    function TransportSendQueue(transport) {\r\n        this.transport = transport;\r\n        this.buffer = [];\r\n        this.executing = true;\r\n        this.sendBufferedData = new PromiseSource();\r\n        this.transportResult = new PromiseSource();\r\n        this.sendLoopPromise = this.sendLoop();\r\n    }\r\n    TransportSendQueue.prototype.send = function (data) {\r\n        this.bufferData(data);\r\n        if (!this.transportResult) {\r\n            this.transportResult = new PromiseSource();\r\n        }\r\n        return this.transportResult.promise;\r\n    };\r\n    TransportSendQueue.prototype.stop = function () {\r\n        this.executing = false;\r\n        this.sendBufferedData.resolve();\r\n        return this.sendLoopPromise;\r\n    };\r\n    TransportSendQueue.prototype.bufferData = function (data) {\r\n        if (this.buffer.length && typeof (this.buffer[0]) !== typeof (data)) {\r\n            throw new Error(\"Expected data to be of type \" + typeof (this.buffer) + \" but was of type \" + typeof (data));\r\n        }\r\n        this.buffer.push(data);\r\n        this.sendBufferedData.resolve();\r\n    };\r\n    TransportSendQueue.prototype.sendLoop = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var transportResult, data, error_1;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (!true) return [3 /*break*/, 6];\r\n                        return [4 /*yield*/, this.sendBufferedData.promise];\r\n                    case 1:\r\n                        _a.sent();\r\n                        if (!this.executing) {\r\n                            if (this.transportResult) {\r\n                                this.transportResult.reject(\"Connection stopped.\");\r\n                            }\r\n                            return [3 /*break*/, 6];\r\n                        }\r\n                        this.sendBufferedData = new PromiseSource();\r\n                        transportResult = this.transportResult;\r\n                        this.transportResult = undefined;\r\n                        data = typeof (this.buffer[0]) === \"string\" ?\r\n                            this.buffer.join(\"\") :\r\n                            TransportSendQueue.concatBuffers(this.buffer);\r\n                        this.buffer.length = 0;\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        _a.trys.push([2, 4, , 5]);\r\n                        return [4 /*yield*/, this.transport.send(data)];\r\n                    case 3:\r\n                        _a.sent();\r\n                        transportResult.resolve();\r\n                        return [3 /*break*/, 5];\r\n                    case 4:\r\n                        error_1 = _a.sent();\r\n                        transportResult.reject(error_1);\r\n                        return [3 /*break*/, 5];\r\n                    case 5: return [3 /*break*/, 0];\r\n                    case 6: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    TransportSendQueue.concatBuffers = function (arrayBuffers) {\r\n        var totalLength = arrayBuffers.map(function (b) { return b.byteLength; }).reduce(function (a, b) { return a + b; });\r\n        var result = new Uint8Array(totalLength);\r\n        var offset = 0;\r\n        for (var _i = 0, arrayBuffers_1 = arrayBuffers; _i < arrayBuffers_1.length; _i++) {\r\n            var item = arrayBuffers_1[_i];\r\n            result.set(new Uint8Array(item), offset);\r\n            offset += item.byteLength;\r\n        }\r\n        return result;\r\n    };\r\n    return TransportSendQueue;\r\n}());\r\nexports.TransportSendQueue = TransportSendQueue;\r\nvar PromiseSource = /** @class */ (function () {\r\n    function PromiseSource() {\r\n        var _this = this;\r\n        this.promise = new Promise(function (resolve, reject) {\r\n            var _a;\r\n            return _a = [resolve, reject], _this.resolver = _a[0], _this.rejecter = _a[1], _a;\r\n        });\r\n    }\r\n    PromiseSource.prototype.resolve = function () {\r\n        this.resolver();\r\n    };\r\n    PromiseSource.prototype.reject = function (reason) {\r\n        this.rejecter(reason);\r\n    };\r\n    return PromiseSource;\r\n}());\r\n//# sourceMappingURL=HttpConnection.js.map","\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// This will be treated as a bit flag in the future, so we keep it using power-of-two values.\r\n/** Specifies a specific HTTP transport type. */\r\nvar HttpTransportType;\r\n(function (HttpTransportType) {\r\n    /** Specifies no transport preference. */\r\n    HttpTransportType[HttpTransportType[\"None\"] = 0] = \"None\";\r\n    /** Specifies the WebSockets transport. */\r\n    HttpTransportType[HttpTransportType[\"WebSockets\"] = 1] = \"WebSockets\";\r\n    /** Specifies the Server-Sent Events transport. */\r\n    HttpTransportType[HttpTransportType[\"ServerSentEvents\"] = 2] = \"ServerSentEvents\";\r\n    /** Specifies the Long Polling transport. */\r\n    HttpTransportType[HttpTransportType[\"LongPolling\"] = 4] = \"LongPolling\";\r\n})(HttpTransportType = exports.HttpTransportType || (exports.HttpTransportType = {}));\r\n/** Specifies the transfer format for a connection. */\r\nvar TransferFormat;\r\n(function (TransferFormat) {\r\n    /** Specifies that only text data will be transmitted over the connection. */\r\n    TransferFormat[TransferFormat[\"Text\"] = 1] = \"Text\";\r\n    /** Specifies that binary data will be transmitted over the connection. */\r\n    TransferFormat[TransferFormat[\"Binary\"] = 2] = \"Binary\";\r\n})(TransferFormat = exports.TransferFormat || (exports.TransferFormat = {}));\r\n//# sourceMappingURL=ITransport.js.map","\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ILogger_1 = require(\"./ILogger\");\r\nvar ITransport_1 = require(\"./ITransport\");\r\nvar Utils_1 = require(\"./Utils\");\r\nvar WeChatWebSocketTransport = /** @class */ (function () {\r\n    function WeChatWebSocketTransport(httpClient, accessTokenFactory, logger, logMessageContent) {\r\n        this.httpClient = httpClient;\r\n        this.accessTokenFactory = accessTokenFactory;\r\n        this.logger = logger;\r\n        this.logMessageContent = logMessageContent;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    WeChatWebSocketTransport.prototype.connect = function (url, transferFormat) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var token;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        Utils_1.Arg.isRequired(url, \"url\");\r\n                        Utils_1.Arg.isRequired(transferFormat, \"transferFormat\");\r\n                        Utils_1.Arg.isIn(transferFormat, ITransport_1.TransferFormat, \"transferFormat\");\r\n                        this.logger.log(ILogger_1.LogLevel.Trace, \"(WebSockets transport) Connecting.\");\r\n                        if (!this.accessTokenFactory) return [3 /*break*/, 2];\r\n                        return [4 /*yield*/, this.accessTokenFactory()];\r\n                    case 1:\r\n                        token = _a.sent();\r\n                        if (token) {\r\n                            url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + (\"access_token=\" + encodeURIComponent(token));\r\n                        }\r\n                        _a.label = 2;\r\n                    case 2: return [2 /*return*/, new Promise(function (resolve, reject) {\r\n                            url = url.replace(/^http/, \"ws\");\r\n                            var webSocket;\r\n                            var cookies = _this.httpClient.getCookieString(url);\r\n                            webSocket = wx.connectSocket({\r\n                                url: url,\r\n                                header: {\r\n                                    cookie: cookies ? \"\" + cookies : undefined,\r\n                                }\r\n                            });\r\n                            // wechat doesn't support this kind of api\r\n                            // if (transferFormat === TransferFormat.Binary) {\r\n                            //     webSocket.binaryType = \"arraybuffer\";\r\n                            // }\r\n                            // tslint:disable-next-line:variable-name\r\n                            webSocket.onOpen(function () {\r\n                                _this.logger.log(ILogger_1.LogLevel.Information, \"WebSocket connected to \" + url + \".\");\r\n                                _this.webSocket = webSocket;\r\n                                resolve();\r\n                            });\r\n                            webSocket.onError(function (event) {\r\n                                var error = null;\r\n                                // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                                error = event.errMsg;\r\n                                if (!error) {\r\n                                    error = new Error(\"There was an error with the transport.\");\r\n                                }\r\n                                reject(error);\r\n                            });\r\n                            webSocket.onMessage(function (message) {\r\n                                _this.logger.log(ILogger_1.LogLevel.Trace, \"(WebSockets transport) data received. \" + Utils_1.getDataDetail(message.data, _this.logMessageContent) + \".\");\r\n                                if (_this.onreceive) {\r\n                                    _this.onreceive(message.data);\r\n                                }\r\n                            });\r\n                            webSocket.onClose(function (event) { return _this.close(event); });\r\n                        })];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    WeChatWebSocketTransport.prototype.send = function (data) {\r\n        if (this.webSocket) {\r\n            this.logger.log(ILogger_1.LogLevel.Trace, \"(WebSockets transport) sending data. \" + Utils_1.getDataDetail(data, this.logMessageContent) + \".\");\r\n            this.webSocket.send({ data: data });\r\n            return Promise.resolve();\r\n        }\r\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\r\n    };\r\n    WeChatWebSocketTransport.prototype.stop = function () {\r\n        if (this.webSocket) {\r\n            // Clear websocket handlers because we are considering the socket closed now\r\n            this.webSocket = undefined;\r\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\r\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\r\n            this.close(undefined);\r\n        }\r\n        return Promise.resolve();\r\n    };\r\n    WeChatWebSocketTransport.prototype.close = function (event) {\r\n        // webSocket will be null if the transport did not start successfully\r\n        this.logger.log(ILogger_1.LogLevel.Trace, \"(WebSockets transport) socket closed.\");\r\n        if (this.onclose) {\r\n            if (event && event.code !== 1000) {\r\n                this.onclose(new Error(\"WebSocket closed with status code: \" + event.code + \" (\" + event.reason + \").\"));\r\n            }\r\n            else {\r\n                this.onclose();\r\n            }\r\n        }\r\n    };\r\n    return WeChatWebSocketTransport;\r\n}());\r\nexports.WeChatWebSocketTransport = WeChatWebSocketTransport;\r\n//# sourceMappingURL=WeChatWebSocketTransport.js.map","\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar IHubProtocol_1 = require(\"./IHubProtocol\");\r\nvar ILogger_1 = require(\"./ILogger\");\r\nvar ITransport_1 = require(\"./ITransport\");\r\nvar Loggers_1 = require(\"./Loggers\");\r\nvar TextMessageFormat_1 = require(\"./TextMessageFormat\");\r\nvar JSON_HUB_PROTOCOL_NAME = \"json\";\r\n/** Implements the JSON Hub Protocol. */\r\nvar JsonHubProtocol = /** @class */ (function () {\r\n    function JsonHubProtocol() {\r\n        /** @inheritDoc */\r\n        this.name = JSON_HUB_PROTOCOL_NAME;\r\n        /** @inheritDoc */\r\n        this.version = 1;\r\n        /** @inheritDoc */\r\n        this.transferFormat = ITransport_1.TransferFormat.Text;\r\n    }\r\n    /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n     *\r\n     * @param {string} input A string containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    JsonHubProtocol.prototype.parseMessages = function (input, logger) {\r\n        // The interface does allow \"ArrayBuffer\" to be passed in, but this implementation does not. So let's throw a useful error.\r\n        if (typeof input !== \"string\") {\r\n            throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\r\n        }\r\n        if (!input) {\r\n            return [];\r\n        }\r\n        if (logger === null) {\r\n            logger = Loggers_1.NullLogger.instance;\r\n        }\r\n        // Parse the messages\r\n        var messages = TextMessageFormat_1.TextMessageFormat.parse(input);\r\n        var hubMessages = [];\r\n        for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {\r\n            var message = messages_1[_i];\r\n            var parsedMessage = JSON.parse(message);\r\n            if (typeof parsedMessage.type !== \"number\") {\r\n                throw new Error(\"Invalid payload.\");\r\n            }\r\n            switch (parsedMessage.type) {\r\n                case IHubProtocol_1.MessageType.Invocation:\r\n                    this.isInvocationMessage(parsedMessage);\r\n                    break;\r\n                case IHubProtocol_1.MessageType.StreamItem:\r\n                    this.isStreamItemMessage(parsedMessage);\r\n                    break;\r\n                case IHubProtocol_1.MessageType.Completion:\r\n                    this.isCompletionMessage(parsedMessage);\r\n                    break;\r\n                case IHubProtocol_1.MessageType.Ping:\r\n                    // Single value, no need to validate\r\n                    break;\r\n                case IHubProtocol_1.MessageType.Close:\r\n                    // All optional values, no need to validate\r\n                    break;\r\n                default:\r\n                    // Future protocol changes can add message types, old clients can ignore them\r\n                    logger.log(ILogger_1.LogLevel.Information, \"Unknown message type '\" + parsedMessage.type + \"' ignored.\");\r\n                    continue;\r\n            }\r\n            hubMessages.push(parsedMessage);\r\n        }\r\n        return hubMessages;\r\n    };\r\n    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {string} A string containing the serialized representation of the message.\r\n     */\r\n    JsonHubProtocol.prototype.writeMessage = function (message) {\r\n        return TextMessageFormat_1.TextMessageFormat.write(JSON.stringify(message));\r\n    };\r\n    JsonHubProtocol.prototype.isInvocationMessage = function (message) {\r\n        this.assertNotEmptyString(message.target, \"Invalid payload for Invocation message.\");\r\n        if (message.invocationId !== undefined) {\r\n            this.assertNotEmptyString(message.invocationId, \"Invalid payload for Invocation message.\");\r\n        }\r\n    };\r\n    JsonHubProtocol.prototype.isStreamItemMessage = function (message) {\r\n        this.assertNotEmptyString(message.invocationId, \"Invalid payload for StreamItem message.\");\r\n        if (message.item === undefined) {\r\n            throw new Error(\"Invalid payload for StreamItem message.\");\r\n        }\r\n    };\r\n    JsonHubProtocol.prototype.isCompletionMessage = function (message) {\r\n        if (message.result && message.error) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n        if (!message.result && message.error) {\r\n            this.assertNotEmptyString(message.error, \"Invalid payload for Completion message.\");\r\n        }\r\n        this.assertNotEmptyString(message.invocationId, \"Invalid payload for Completion message.\");\r\n    };\r\n    JsonHubProtocol.prototype.assertNotEmptyString = function (value, errorMessage) {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            throw new Error(errorMessage);\r\n        }\r\n    };\r\n    return JsonHubProtocol;\r\n}());\r\nexports.JsonHubProtocol = JsonHubProtocol;\r\n//# sourceMappingURL=JsonHubProtocol.js.map"]}